#include <Arduino.h>

#include <Wire.h>
#include <HWCDC.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include <Preferences.h>

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"


// #include "sdkconfig.h" // generated by "make menuconfig"

#include "mbedtls/esp_config.h"

#define SDA2_PIN GPIO_NUM_18
#define SCL2_PIN GPIO_NUM_19

#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1


/* void i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA2_PIN,
		.scl_io_num = SCL2_PIN,
		.sda_pullup_en = GPIO_PULLUP_DISABLE,
		.scl_pullup_en = GPIO_PULLUP_DISABLE,
		//.master.clk_speed = 100000,
		};
			
	i2c_param_config(I2C_NUM_0 , &i2c_config);
	i2c_driver_install(I2C_NUM_0 , I2C_MODE_MASTER, 0, 0, 0);
}
*/

#include <assert.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <string.h>
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"

#include <OSCBundle.h>
#include <OSCBoards.h>
#include <SLIPEncodedSerial.h>

//SLIPEncodedSerial SLIPSerial(Serial);  for regular ESP32
//HardwareSerial MySerial(0);
//SLIPEncodedSerial SLIPSerial(Serial); // for XIAO ESP32C3

#include "secp256k1.h"
#include "wally_core.h"
#include "wally_crypto.h"
#include "wally_bip32.h"
#include "wally_bip39.h"
#include "wally_address.h"


#include "wally_script.h"
#include "wally_psbt.h"

extern "C" {
#include "ccan/base64/base64.h"
}

// Endianess
#define SPI_SHIFT_DATA(data, len) __builtin_bswap32((uint32_t)data<<(32-len))
#define SPI_REARRANGE_DATA(data, len) (__builtin_bswap32(data)>>(32-len))

// forward declaration
void err(const char * message, void * data = NULL);

// root HD key
ext_key root;

#define FROMHEX_MAXLEN 512

void memzero(void *const pnt, const size_t len) {
/*#ifdef _WIN32
  SecureZeroMemory(pnt, len);
#elif defined(HAVE_MEMSET_S)
  memset_s(pnt, (rsize_t)len, 0, (rsize_t)len);
#elif defined(HAVE_EXPLICIT_BZERO)
  explicit_bzero(pnt, len);
#elif defined(HAVE_EXPLICIT_MEMSET)
  explicit_memset(pnt, 0, len);
#else*/
  volatile unsigned char *volatile pnt_ = (volatile unsigned char *volatile)pnt;
  size_t i = (size_t)0U;

  while (i < len) {
    pnt_[i++] = 0U;
  }
// #endif
}

const uint8_t *fromhex(const char *str) {
  static uint8_t buf[FROMHEX_MAXLEN];
  int len = strlen(str) / 2;
  if (len > FROMHEX_MAXLEN) len = FROMHEX_MAXLEN;
  for (int i = 0; i < len; i++) {
    uint8_t c = 0;
    if (str[i * 2] >= '0' && str[i * 2] <= '9') c += (str[i * 2] - '0') << 4;
    if ((str[i * 2] & ~0x20) >= 'A' && (str[i * 2] & ~0x20) <= 'F')
      c += (10 + (str[i * 2] & ~0x20) - 'A') << 4;
    if (str[i * 2 + 1] >= '0' && str[i * 2 + 1] <= '9')
      c += (str[i * 2 + 1] - '0');
    if ((str[i * 2 + 1] & ~0x20) >= 'A' && (str[i * 2 + 1] & ~0x20) <= 'F')
      c += (10 + (str[i * 2 + 1] & ~0x20) - 'A');
    buf[i] = c;
  }
  return buf;
}

void tohexprint(char *hexbuf, uint8_t *str, int strlen){
   // char hexbuf[strlen];
    for (int i = 0 ; i < strlen/2 ; i++) {
        sprintf(&hexbuf[2*i], "%02X", str[i]);
    }
  hexbuf[strlen-2] = '\0';
}

size_t toHex(const uint8_t * array, size_t arraySize, char * output, size_t outputSize){
    if(array == NULL || output == NULL){ return 0; }
    // uint8_t * array = (uint8_t *) arr;
    if(outputSize < 2*arraySize){
        return 0;
    }
    memzero(output, outputSize);

    for(size_t i=0; i < arraySize; i++){
        output[2*i] = (array[i] >> 4) + '0';
        if(output[2*i] > '9'){
            output[2*i] += 'a'-'9'-1;
        }

        output[2*i+1] = (array[i] & 0x0F) + '0';
        if(output[2*i+1] > '9'){
            output[2*i+1] += 'a'-'9'-1;
        }
    }
    return 2*arraySize;
}

String toHex(const uint8_t * array, size_t arraySize){
    if(array == NULL){ return String(); }
    size_t outputSize = arraySize * 2 + 1;
    char * output = (char *) malloc(outputSize);
    if(output == NULL){ return String(); }

    toHex(array, arraySize, output, outputSize);

    String result(output);

    memzero(output, outputSize);
    free(output);

    return result;
}

//HardwareSerial Serial0(0);
HWCDC SerialESP;
SLIPEncodedSerial SLIPSerial(SerialESP); // for XIAO ESP32C3  
//SLIPEncodedSerial SLIPSerial(Serial); // for AI Thinker ESP-C3-32S

Preferences valise;    // ESP32-C3 to use NVS


void setup()
{
    //begin communication via IÂ²C
    //Wire.setPins(SDA_PIN, SCL_PIN);
    //Wire.begin(SDA_PIN, SCL_PIN);

    SLIPSerial.begin(115200);
    //Serial.begin(115200);

} 

void routeValiseInit(OSCMessage &msg, int addressOffset)
{
    boolean res; 

    valise.begin("vault", false);

    const char* mnemonic = "wife balcony tortoise among impact arch conduct bronze vehicle story menu next brisk rigid mimic scissors monitor worth talk vanish cereal fence excess danger";
    valise.putString("valise_mnemonic", mnemonic);

    valise.end();

    OSCMessage resp_msg("/valiseInit");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}

void routeValiseGet(OSCMessage &msg, int addressOffset)
{
    valise.begin("vault", false);

    String valise_mnemonic = valise.getString("valise_mnemonic", "");

    valise.end();

    OSCMessage resp_msg("/valiseGet");
    resp_msg.add(valise_mnemonic.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}


void routeWallyInit(OSCMessage &msg, int addressOffset)
{
  wally_init(0x00);

  OSCMessage resp_msg("/wallyInit");
  resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}


void routeWallyCleanup(OSCMessage &msg, int addressOffset)
{
  wally_cleanup(0x00);

  OSCMessage resp_msg("/wallyCleanup");
  resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}

void routeWallyGetSecpContext(OSCMessage &msg, int addressOffset)
{
  secp256k1_context_struct *ctxStrct;
  wally_get_secp_context();

  OSCMessage resp_msg("/wallyGetSecpContext");
  resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}

void routeWallyGetNewSecpContext(OSCMessage &msg, int addressOffset)
{
  secp256k1_context_struct *ctxStrct;
  // wally_get_new_secp_context();

  OSCMessage resp_msg("/wallyGetNewSecpContext");
  resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}

void routeWallySecpContextFree(OSCMessage &msg, int addressOffset)
{
  secp256k1_context_struct *ctxStrct;
  //wally_secp_context_free(ctxStrct);

  OSCMessage resp_msg("/wallySecpContextFree");
  resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}


void routeWallyBZero(OSCMessage &msg, int addressOffset)
{
  char *bytes;
  size_t len;
  wally_bzero(bytes, len);

  OSCMessage resp_msg("/wallyBZero");
  resp_msg.add("0");
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}

void routeWallyFreeString(OSCMessage &msg, int addressOffset)
{
  char *str;
  wally_free_string(str);

  OSCMessage resp_msg("/wallyBZero");
  resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
}

void routeWallySecpRandomize(OSCMessage &msg, int addressOffset)
{
  unsigned char *bytes;
  size_t len;
  wally_secp_randomize(bytes, len);

  OSCMessage resp_msg("/wallyBZero");
  resp_msg.add("0");
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}


/* ----------------------------------------------------------------*/
/* Crypto functions                                                */
/* ----------------------------------------------------------------*/

/* part of documentation but deprecated */
/* void routeWallyEcSigFromBytesLen(OSCMessage &msg, int addressOffset)
{
  int res;
  //uint8_t priv_key[33] = "7BC81198140916367B5CED9BADA28C37"; 
  uint8_t priv_key[33];
  size_t priv_key_len;
  // uint8_t hash_key[33] = "C99A85979AD295811330C5689C730250";
  uint8_t hash_key[33];
  size_t hash_key_len;
  uint32_t flags;
  size_t* len;

  priv_key_len = 32;
  hash_key_len = 32;
  int length;

  if(msg.isString(0))
  {
      length=msg.getDataLength(0);
      msg.getString(0, (char*)priv_key,length);
  }

  if(msg.isString(2))
  {
      length=msg.getDataLength(2);
      msg.getString(2, (char*)hash_key,length);  
  }


  res = wally_ec_sig_from_bytes_len(
            (uint8_t*)priv_key, 
            priv_key_len, 
            (uint8_t*)hash_key, 
            hash_key_len, 
            EC_FLAG_ECDSA, 
            (unsigned char*)len
        );

  OSCMessage resp_msg("/IHW/wallyEcSigFromBytesLen");
  resp_msg.add(len);

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
} */

void routeWallyEcSigFromBytes(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t priv_key[32];
  char char_priv_key[65]; // has to be inside the msg.isString() check ...

  uint8_t hash_key[32];
  char char_hash_key[65]; // has to be inside the msg.isString() check ...

  uint8_t bytes_out[64];


  if(msg.isString(0))
  {
      int length=msg.getDataLength(0);
      msg.getString(0, char_priv_key, length);
  }
  if(msg.isString(2))
  {
      int length=msg.getDataLength(2);
      msg.getString(2, char_hash_key, length); 
  }

  
  memcpy(priv_key,
         fromhex((const char*)char_priv_key),
         32
  );
  memcpy(hash_key,
         fromhex((const char*)char_hash_key),
         32
  );

  res = wally_ec_sig_from_bytes(
            priv_key,
            32,
            hash_key,
            32,
            EC_FLAG_ECDSA, 
            bytes_out, 
            64
  );

  /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(bytes_out, 64);

  OSCMessage resp_msg("/IHW/wallyEcSigFromBytes");
  resp_msg.add(hexStr.c_str());
  resp_msg.add(char_priv_key);
  resp_msg.add(char_hash_key);


  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

  wally_free_string(char_priv_key);
  wally_free_string(char_hash_key);

}

void routeWallyEcSigNormalize(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t sig[64];
  char char_sig[129];

  uint8_t bytes_out[64]; 
 

  if(msg.isString(0))
  {
      int length=msg.getDataLength(0);
      msg.getString(0, char_sig, length);
  }

  memcpy(sig,
         fromhex(char_sig),
         64
  );

  res = wally_ec_sig_normalize(
            sig, 
            EC_SIGNATURE_LEN, 
            bytes_out, 
            EC_SIGNATURE_LEN
  );

  /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(bytes_out, 64);

  OSCMessage resp_msg("/IHW/wallyEcSigNormalize");
  resp_msg.add(hexStr.c_str());
  // resp_msg.add("test message");
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}

void routeWallyEcSigToDer(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t sig[64];

  char str_sig[129];

  uint8_t der[73]; 

  size_t len;

  if(msg.isString(0))
  {
      int length=msg.getDataLength(0);
      msg.getString(0, str_sig,length);
  }

  memcpy(sig,
         fromhex(str_sig),
         64
  );

  res = wally_ec_sig_to_der(
            sig, 
            EC_SIGNATURE_LEN, 
            der, 
            EC_SIGNATURE_DER_MAX_LEN,
            &len
  );

  /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(der, EC_SIGNATURE_DER_MAX_LEN);

  OSCMessage resp_msg("/IHW/wallyEcSigToDer");
  resp_msg.add(hexStr.c_str());
  //resp_msg.add("test message");
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}

void routeWallyEcSigFromDer(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t der[72];

  char str_der[145];

  uint8_t sig[64]; 
 

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_der, length);
  };
  memcpy(der, 
        fromhex(str_der),
        72
  );

  res = wally_ec_sig_from_der(
            der, 
            72, 
            sig, 
            64
  );

  /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(sig, 64);

  OSCMessage resp_msg("/IHW/wallyEcSigFromDer");
  resp_msg.add(hexStr.c_str());
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}

void routeWallyEcSigVerify(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t pub_key[33];
  char str_pub_key[67];

  uint8_t hash[32];
  char str_hash[65];

  uint8_t sig[64];
  char str_sig[129];

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_pub_key, length);
  };
  memcpy(pub_key, 
        fromhex(str_pub_key),
        33
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(0);
    msg.getString(1, (char*)str_hash, length);
  };
  memcpy(hash, 
        fromhex(str_hash),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_sig, length);
  }
  memcpy(sig, 
        fromhex(str_sig),
        64
  );

  res = wally_ec_sig_verify(
            pub_key, 
            33, 
            hash,
            32,
            EC_FLAG_ECDSA,
            sig, 
            64
  );

  OSCMessage resp_msg("/IHW/wallyEcSigVerify");
  resp_msg.add("True");
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}

void routeWallyEcSigToPublicKey(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t pub_key[33];

  uint8_t hash[32];
  char str_hash[65];

  uint8_t sig[64];
  char str_sig[129];

  size_t len;



  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_hash, length);
  };
  memcpy(hash, 
        fromhex(str_hash),
        32
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(2);
    msg.getString(1, (char*)str_sig, length);
  }
  memcpy(sig, 
        fromhex(str_sig),
        64
  );

  res = wally_ec_sig_to_public_key(
            hash,
            32,
            sig, 
            64,
            pub_key,
            len
  );

 /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(pub_key, 33);

  OSCMessage resp_msg("/IHW/wallyEcSigToPublicKey");
  resp_msg.add(hexStr.c_str());
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}


void routeWallyFormatBitcoinMessage(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t btc_msg[512];
  char str_btc_msg[1025];

  uint8_t btc_msg_hash[32];

  int* len;
  size_t* written;

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_btc_msg, length);
    len = &length;
  };

  memcpy(btc_msg, 
        fromhex(str_btc_msg),
        *len
  );

  res = wally_format_bitcoin_message(
        btc_msg, *len,
        BITCOIN_MESSAGE_FLAG_HASH,
        btc_msg_hash, 32,
        written
  );

  /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(btc_msg_hash, 32);

  OSCMessage resp_msg("/IHW/wallyFormatBitcoinMessage");
  resp_msg.add(hexStr.c_str());
  resp_msg.add(str_btc_msg);
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

}

void routeWallyEcdh(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t pub_key[33]; 
  char str_pub_key[66];

  uint8_t priv_key[32];
  char str_priv_key[64];

  uint8_t shared_secret[32];


  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, str_pub_key, length);
  };

  memcpy(pub_key, 
        fromhex(str_pub_key),
        33
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, str_priv_key, length);
  };

  memcpy(priv_key, 
        fromhex(str_priv_key),
        32
  );


  res = wally_ecdh(
        (const unsigned char *)pub_key, EC_PUBLIC_KEY_LEN,
        (const unsigned char *)priv_key, EC_PRIVATE_KEY_LEN,
        (unsigned char*)shared_secret, SHA256_LEN
  );

  /* Requirement by Arduino to stream strings back to requestor */
  String hexStr;
  hexStr = toHex(shared_secret, 32);

  String hexStrPub;
  hexStrPub = toHex(pub_key, 33);

  String hexStrPriv;
  hexStrPriv = toHex(priv_key, 32);

  OSCMessage resp_msg("/IHW/wallyEcdh");
  resp_msg.add(hexStr.c_str());
  resp_msg.add(hexStrPub.c_str());
  resp_msg.add(hexStrPriv.c_str());

  //resp_msg.add(str_pub_key);
  //resp_msg.add(str_priv_key);
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

}

/*void routeWallyS2cSigFromBytes(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t priv_key[32];
  char str_priv_key[66];  // /* EC_PRIVATE_KEY_LEN - 32

  uint8_t msg_hash[32];
  char str_msg_hash[66]; // /* EC_MESSAGE_HASH_LEN - 32 

  uint8_t s2c_data[32];
  char str_s2c_data[66]; // /* WALLY_S2C_DATA_LEN - 32 

  // /* EC_FLAG_ECDSA 

  uint8_t s2c_opening_out[33];
  char str_s2c_opening_out[68]; // /* WALLY_S2C_OPENING_LEN - 32 

  uint8_t sig[64]; // /* EC_SIGNATURE_LEN - 64 

  int len = 64;

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_priv_key, length);
  };

  memcpy(priv_key, 
        fromhex(str_priv_key),
        32
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, (char*)str_msg_hash, length);
  };

  memcpy(msg_hash, 
        fromhex(str_msg_hash),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_s2c_data, length);
  };

  memcpy(s2c_data, 
        fromhex(str_s2c_data),
        32
  );

  res = wally_s2c_sig_from_bytes(
      priv_key, 32,
      msg_hash, 32,
      s2c_data, 32,
      EC_FLAG_ECDSA, 
      s2c_opening_out, 33,
      sig, 64
  ) 

  // /* Requirement by Arduino to stream strings back to requestor 
  String hexStrS2cOpeningOut;
  hexStrS2cOpeningOut = toHex(s2c_opening_out, 33);

  String hexStrSig;
  hexStrSig = toHex(sig, 64);


  OSCMessage resp_msg("/IHW/wallyS2cSigFromBytes");
  resp_msg.add(hexStrS2cOpeningOut.c_str());
  resp_msg.add(hexStrSig.c_str());

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

} */


/* void routeWallyS2cCommitmentVerify(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t sig[64]; // /* EC_SIGNATURE_LEN - 64 
  char str_sig[128];

  uint8_t s2c_data[32];
  char str_s2c_data[66]; // /* WALLY_S2C_DATA_LEN - 32 

  uint8_t s2c_opening_out[33];
  char str_s2c_opening_out[68]; // /* WALLY_S2C_OPENING_LEN - 32 

  // /* EC_FLAG_ECDSA 

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_sig, length);
  };

  memcpy(sig, 
        fromhex(str_sig),
        64
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, (char*)str_s2c_data, length);
  };

  memcpy(s2c_data, 
        fromhex(str_s2c_data),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_s2c_opening_out, length);
  };

  memcpy(s2c_opening_out, 
        fromhex(str_s2c_opening_out),
        33
  );

  res = wally_s2c_commitment_verify(
      sig, 64,
      s2c_data, 32, 
      s2c_opening_out, 33,
      EC_FLAG_ECDSA
  ) 

  OSCMessage resp_msg("/IHW/wallyCommitmentVerify");
  resp_msg.add("True");

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

} */


/* ----------------------------------------------------------------*/
/* wally bip39 functions                                           */
/* ----------------------------------------------------------------*/

void routeBip39GetLanguages(OSCMessage &msg, int addressOffset)
{
  int res;
  char *output = NULL;

  res = bip39_get_languages(&output);

  OSCMessage resp_msg("/bip39GetLanguages");
  resp_msg.add(output);
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

  wally_free_string(output);
}

void routeBip39GetWordlist(OSCMessage &msg, int addressOffset)
{
  int res;

  if(msg.isString(0))
  {
    struct words *output;
    int length=msg.getDataLength(0);
    char lang[length];
    msg.getString(0,lang,length);

    res = bip39_get_wordlist(lang, &output);

    OSCMessage resp_msg("/bip39GetWordlist");
    resp_msg.add(output);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
  }
}

void routeBip39GetWord(OSCMessage &msg, int addressOffset)
{
  int res;
  struct words *w;

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    char lang[length];
    msg.getString(0,lang,length);
    res = bip39_get_wordlist(lang, &w);
  }

  if(msg.isInt(1))
  {
    // don't forget problem with endianess
    char *output;
    int nth_word = msg.getInt(1);
    res = bip39_get_word(w, nth_word, &output);

    OSCMessage resp_msg("/bip39GetWordlist");

    char str_nth_word[10];
    sprintf(str_nth_word, "%d", nth_word);
    resp_msg.add(str_nth_word);
    resp_msg.add(output);

    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();

    wally_free_string(output);
  }
}

void routeBip39NumberBouncer(OSCMessage &msg, int addressOffset)
{
  int res;

  if(msg.isInt(0))
  {
    int nth_word = msg.getInt(0);

    OSCMessage resp_msg("/bip39GetNumberBouncer");

    char str_nth_word[10];
    sprintf(str_nth_word, "%d", nth_word);
    resp_msg.add((int32_t)nth_word);

    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
  }
}

void routeBipMnemonicFromBytes(OSCMessage &msg, int addressOffset)
{
  boolean b;
}

void routeBipMnemonicToBytes(OSCMessage &msg, int addressOffset)
{
  boolean b;
}

void routeBipMnemonicValidate(OSCMessage &msg, int addressOffset)
{
  boolean b;
}

void routeMnemonicToSeed(OSCMessage &msg, int addressOffset)
{
    int res;

    char phrase[512];
    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, phrase, length);
    }

    // Convert mnemonic to seed
    uint8_t seed[BIP39_SEED_LEN_512];
    size_t seed_len;
    res = bip39_mnemonic_to_seed(phrase, "my password", seed, sizeof(seed), &seed_len);
    // Generate BIP32 master key from seed
    res = bip32_key_from_seed(seed, sizeof(seed), BIP32_VER_MAIN_PRIVATE, 0, &root);

    // // Clear seed from memory for security
    memset(seed, 0, sizeof(seed_len));

    // // // Convert master_key to base58 string
    char *base58_master_key = NULL;
    res = bip32_key_to_base58(&root, BIP32_FLAG_KEY_PRIVATE, &base58_master_key);

    // Send the result back
    OSCMessage resp_msg("/IHW/mnemonicToSeed");
    resp_msg.add(base58_master_key);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(base58_master_key);
    wally_free_string(phrase);
}

void routeBipMnemonicToSeed512(OSCMessage &msg, int addressOffset)
{
  boolean b;
}


void routeMnemonic(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
 
    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes(NULL, se_rnd, sizeof(se_rnd), &phrase);

    msg.add(phrase);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    msg.empty();
}

void routeEntropy(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    //const char *seed;
    //seed = toHex(se_rnd, 32).c_str();

    char seed[32];
  
    memset(seed, '\0', sizeof(seed));
    for (int i=0; i<31; i++)
    {
        static char tmp[4] = {};
        sprintf(tmp, "%02X", se_rnd[i]);
        strcpy(seed+i, tmp);
    }

    //msg.add("2573548DF4251F3048ABA137EFEEC11E59C0738D47C88B46462EDE80BEFFA2CA");

    msg.add(seed);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    msg.empty();
}

void routeTrnd(OSCMessage &msg, int addressOffset)
{
    int len;

    if (msg.isInt(0))
    { 
        len = msg.getInt(0);
        uint8_t se_rnd[len] = {0};
        esp_fill_random(se_rnd, len);

        char trnd[len];
        memset(trnd, '\0', sizeof(trnd));
        for (int i=0; i<len-1; i++)
        {
            static char tmp[4] = {};
            sprintf(tmp, "%02X", se_rnd[i]);
            strcpy(trnd+i, tmp);
        }

        msg.add(trnd);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
            msg.send(SLIPSerial);
        SLIPSerial.endPacket(); 
        msg.empty();
    }
}

void routeCborEcho(OSCMessage &msg, int addressOffset)
{

    OSCMessage msg2("/cbor/echo");
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes(NULL, se_rnd, sizeof(se_rnd), &phrase);

    msg2.add("d08355a20101055001010101010101010101010101010101a10458246d65726961646f632e6272616e64796275636b406275636b6c616e642e6578616d706c655820c4af85ac4a5134931993ec0a1863a6e8c66ef4c9ac16315ee6fecd9b2e1c79a1");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        msg2.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    msg.empty();
}

void routeMnemonicToBytes(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];

    if(msg.isString(0))
    {
      int length = msg.getDataLength(0);
      char phrase[length];
      msg.getString(0,phrase,length);
      //Serial.println(phrase);

      // converting recovery phrase to bytes
      res = bip39_mnemonic_to_bytes(NULL, phrase, bytes_out, sizeof(bytes_out), &len);
    }

    String hexStr;
    hexStr = toHex(bytes_out, 32);
    //Serial.println(hexStr);

    OSCMessage resp_msg("/mnemonicToBytes");
    resp_msg.add(hexStr.c_str());
    //resp_msg.add("hello");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
    delay(20);
}

void routeMnemonicFromBytes(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];
    char *phrase = NULL;

    if(msg.isString(0))
    {
      int length = msg.getDataLength(0);
      char hexStr[length];
      msg.getString(0,hexStr,length);
      //Serial.println(hexStr);
      
      res = bip39_mnemonic_from_bytes(NULL, (const unsigned char*)fromhex(hexStr), 32, &phrase);
    }

    OSCMessage resp_msg("/mnemonicFromBytes");
    resp_msg.add(phrase);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    resp_msg.empty();
    delay(20);
}

void routeBip32KeyFromParent(OSCMessage &msg, int addressOffset)
{
    int res;

    char parent_key[112];
    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, parent_key, length);
    }

    uint32_t child_index = msg.getInt(2);

    // Convert base58 parent key to ext_key structure
    ext_key parent_ext_key;
    res = bip32_key_from_base58(parent_key, &parent_ext_key);
    if (res != WALLY_OK)
    {
        // Handle the error
        Serial.println("Error: Failed to convert parent key from base58");
        return;
    }

    // Derive child key from parent key
    ext_key child_ext_key;
    res = bip32_key_from_parent(&parent_ext_key, child_index, BIP32_FLAG_KEY_PRIVATE, &child_ext_key);
    if (res != WALLY_OK)
    {
        // Handle the error
        Serial.println("Error: Failed to derive child key from parent key");
        return;
    }

    // Convert child_ext_key to base58 string
    char *base58_child_key = NULL;
    res = bip32_key_to_base58(&child_ext_key, BIP32_FLAG_KEY_PRIVATE, &base58_child_key);
    if (res != WALLY_OK)
    {
        // Handle the error
        Serial.println("Error: Failed to convert child key to base58");
        return;
    }

    // Send the result back
    OSCMessage resp_msg("/IHW/bip32KeyFromParent");
    resp_msg.add(base58_child_key);
    resp_msg.add(parent_key);
    resp_msg.add((int32_t)child_index);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(base58_child_key);
}

void routeBip32KeyToAddress(OSCMessage &msg, int addressOffset)
{
    int res;

    // ext_key hdkey;
    // char char_ext_key[111]; // has to be inside the msg.isString() check ...

    // char *output = NULL;

    // if (msg.isString(0))
    // {
        // int length = msg.getDataLength(0);
        // msg.getString(0, char_ext_key, length);
    // }

    // res = bip32_key_from_base58(char_ext_key, &hdkey);

    // res = wally_bip32_key_to_addr_segwit(&hdkey, "bc", 0, &output);
//    res = wally_bip32_key_to_address(&hdkey, WALLY_ADDRESS_TYPE_P2SH_P2WPKH, WALLY_ADDRESS_VERSION_P2PKH_MAINNET, &output);


    // Send the result back
    OSCMessage resp_msg("/IHW/bip32KeyToAddress");
    resp_msg.add("FOOOOO");

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    // Send the result back
    // resp_msg.add(char_ext_key);
    // wally_free_string(output);
}

void routeBip32KeyFromSeed(OSCMessage &msg, int addressOffset)
{
    int res;
    int res2;
    size_t len;

    if(msg.isString(0))
    {
        //res = wally_init(0);

        int length=msg.getDataLength(0);

        char hexStr[length];
        msg.getString(0,hexStr,length);

        /**************** BIP-39 recovery phrase ******************/

        // random buffer should be generated by TRNG or somehow else
        // but we will use predefined one for demo purposes
        // 16 bytes will generate a 12-word recovery phrase
        uint8_t rnd[] = {
            0xAC, 0x91, 0xD3, 0xBC, 0x1B, 0x7C, 0x06, 0x2E,
            0x21, 0xB5, 0x86, 0xA0, 0x2D, 0xBE, 0x5D, 0x24
        };

         // creating a recovery phrase
        char *phrase = NULL;
        res = bip39_mnemonic_from_bytes(NULL, (const unsigned char*)fromhex((const char*)hexStr), 32, &phrase);
        //res = bip39_mnemonic_from_bytes(NULL, rnd, sizeof(rnd), &phrase);
        

        // converting recovery phrase to seed
        uint8_t seed[BIP39_SEED_LEN_512];
        res2 = bip39_mnemonic_to_seed(phrase, "my password", seed, sizeof(seed), &len);

        // don't forget to securely clean up the string when done
        wally_free_string(phrase);

        res = bip32_key_from_seed(seed, sizeof(seed), BIP32_VER_TEST_PRIVATE, 0, &root);
        //get base58 xprv string
        char *xprv = NULL;
        res = bip32_key_to_base58(&root, BIP32_FLAG_KEY_PRIVATE, &xprv);

        msg.add(xprv);
    }

    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        msg.send(SLIPSerial);
    SLIPSerial.endPacket(); 
    msg.empty();
}

void routeBip32KeyFromParentPath(OSCMessage &msg, int addressOffset)
{
  boolean b;
}

void routeBip32KeyFromBase58(OSCMessage &msg, int addressOffset)
{
  boolean b;
}

void routeSlip21KeyFromSeed(OSCMessage &msg, int addressOffset)
{
  boolean b;
}

void loop()
{
    OSCMessage msg;
    int size;
    //receive a bundle
    while(!SLIPSerial.endofPacket())
        if( (size =SLIPSerial.available()) > 0)
        {
            while(size--)
              msg.fill(SLIPSerial.read());
        }
    
    if(!msg.hasError())
    {
      /* Core functions */
        msg.route("/IHW/wallyInit", routeWallyInit);
        msg.route("/IHW/wallyCleanup", routeWallyCleanup);
        msg.route("/IHW/wallyGetSecpContext", routeWallyGetSecpContext);
        msg.route("/IHW/wallyGetNewSecpContext", routeWallyGetNewSecpContext);
        msg.route("/IHW/wallySecpContextFree", routeWallySecpContextFree);
        msg.route("/IHW/wallyBZero", routeWallyBZero);
        msg.route("/IHW/wallyFreeString", routeWallyFreeString);
        msg.route("/IHW/wallySecpRandomize", routeWallySecpRandomize);

      /* Crypto functions */
        
        // deprecated in libwally-core code base
        // msg.route("/IHW/wallyEcSigFromBytesLen", routeWallyEcSigFromBytesLen);
        msg.route("/IHW/wallyEcSigFromBytes", routeWallyEcSigFromBytes);
        msg.route("/IHW/wallyEcSigNormalize", routeWallyEcSigNormalize);
        msg.route("/IHW/wallyEcSigToDer", routeWallyEcSigToDer);
        msg.route("/IHW/wallyEcSigFromDer", routeWallyEcSigFromDer);
        msg.route("/IHW/wallyEcSigVerify", routeWallyEcSigVerify);
        msg.route("/IHW/wallyEcSigToPublicKey", routeWallyEcSigToPublicKey);
        msg.route("/IHW/wallyFormatBitcoinMessage", routeWallyFormatBitcoinMessage);
        msg.route("/IHW/wallyEcdh", routeWallyEcdh);
        // only available starting from version release_0.8.8
        // msg.route("/IHW/wallyS2cSigFromBytes", routeWallyS2cSigFromBytes);
        // msg.route("/IHW/wallyS2cCommitmentVerify", routeWallyS2cCommitmentVerify);

      /* Vaise functions */
        msg.route("/IHW/valiseInit", routeValiseInit);
        msg.route("/IHW/valiseGet", routeValiseGet);

      /* Bip39 functions*/
        msg.route("/IHW/bip39GetLanguages", routeBip39GetLanguages);
        msg.route("/IHW/bip39GetWordlist", routeBip39GetWordlist);
        msg.route("/IHW/bip39GetWord", routeBip39GetWord);
        msg.route("/IHW/bip39MnemonicFromBytes", routeBipMnemonicFromBytes);
        msg.route("/IHW/bip39MnemonicToBytes", routeBipMnemonicToBytes);
        msg.route("/IHW/bip39MnemonicValidate", routeBipMnemonicValidate);
        msg.route("/IHW/mnemonicToSeed", routeMnemonicToSeed);
//        msg.route("/IHW/bip39MnemonicToSeed512", routeBipMnemonicToSeed512);
        msg.route("/IHW/bip39NumberBouncer", routeBip39NumberBouncer);
        
        msg.route("/IHW/mnemonic", routeMnemonic);
        msg.route("/IHW/mnemonicFromBytes", routeMnemonicFromBytes);
        msg.route("/IHW/mnemonicToBytes", routeMnemonicToBytes);
        //msg.route("/IHW/seed", routeEntropy);
        msg.route("/IHW/bip32_key_from_seed", routeBip32KeyFromSeed);
        msg.route("/IHW/bip32KeyFromParent", routeBip32KeyFromParent);
        msg.route("/IHW/bip32KeyToAddress", routeBip32KeyToAddress);

        
        // msg.route("/IHW/bip32_key_from_parent_path", routeBip32KeyFromParentPath);
        // msg.route("/IHW/bip32_key_from_base58", routeBip32KeyFromBase58);
        msg.route("/IHW/slip21_key_from_seed", routeSlip21KeyFromSeed);
        msg.route("/IHW/trnd", routeTrnd);
        // msg.route("/IHW/cbor", routeCborEcho);
    }

    /*if(!msg.hasError())
    {
        static int32_t sequencenumber=0;
        // we can sneak an addition onto the end of the bundle
        msg.add("/sequencenumber").add(sequencenumber++);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
            msg.send(SLIPSerial);
        SLIPSerial.endPacket();     
    }*/


  delay(20);
}
