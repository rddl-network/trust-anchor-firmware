#include <Arduino.h>

#include "secp256k1.h"
#include "secp256k1_preallocated.h"

#include <Wire.h>
#include <HWCDC.h>

#include <iostream>
#include <vector>
#include <WString.h>
#include <sstream>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_system.h"
#include "esp_partition.h"
#include "nvs_flash.h"
#include <Preferences.h>

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"

#define BIP32_INITIAL_HARDENED_CHILD 0x80000000

char tempBuff[1024];

std::vector<uint32_t> getPath(char *pathStr);

std::vector<uint32_t> getPath(char *pathStr)
{
    std::vector<uint32_t> myPath;
    uint32_t num = 0;
    char *token = strtok(pathStr + 2, "/"); /* derivation path always starts with 'm/' */
    token = strtok(NULL, "/");

    while (token != NULL)
    {
        size_t s = strlen(token);
        char t = token[s - 1];

        if (t == '\'')
        {
            token[s - 1] = '\0';
            num = BIP32_INITIAL_HARDENED_CHILD;
        }
        else
            num = 0;

        num += std::stoi(token);
        myPath.push_back(num);
        token = strtok(NULL, "/");
    }
    return myPath;
}

// #include "sdkconfig.h" // generated by "make menuconfig"

#include "mbedtls/esp_config.h"

#define SDA2_PIN GPIO_NUM_18
#define SCL2_PIN GPIO_NUM_19

#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1

/* void i2c_master_init()
{
    i2c_config_t i2c_config = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = SDA2_PIN,
        .scl_io_num = SCL2_PIN,
        .sda_pullup_en = GPIO_PULLUP_DISABLE,
        .scl_pullup_en = GPIO_PULLUP_DISABLE,
        //.master.clk_speed = 100000,
        };

    i2c_param_config(I2C_NUM_0 , &i2c_config);
    i2c_driver_install(I2C_NUM_0 , I2C_MODE_MASTER, 0, 0, 0);
}
*/

#include <assert.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <string.h>
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"

#include <OSCBundle.h>
#include <OSCBoards.h>
#include "SLIPEncodedSerial.h"

// SLIPEncodedSerial SLIPSerial(Serial);  for regular ESP32
// HardwareSerial MySerial(0);
// SLIPEncodedSerial SLIPSerial(Serial); // for XIAO ESP32C3

#include "secp256k1.h"
#include "wally_core.h"
#include "wally_crypto.h"
#include "wally_bip32.h"
#include "wally_bip39.h"
#include "wally_address.h"
#include "wally_symmetric.h"

#include "wally_script.h"
#include "wally_psbt.h"

#define EC_FLAGS_TYPES (EC_FLAG_ECDSA | EC_FLAG_SCHNORR)

static bool is_valid_ec_type(uint32_t flags)
{
    return ((flags & EC_FLAGS_TYPES) == EC_FLAG_ECDSA) ||
           ((flags & EC_FLAGS_TYPES) == EC_FLAG_SCHNORR);
}

extern "C"
{
#include "ccan/base64/base64.h"
}

// Endianess
#define SPI_SHIFT_DATA(data, len) __builtin_bswap32((uint32_t)data << (32 - len))
#define SPI_REARRANGE_DATA(data, len) (__builtin_bswap32(data) >> (32 - len))

// forward declaration
void err(const char *message, void *data = NULL);

// root HD key
ext_key root;

#define FROMHEX_MAXLEN 512

void memzero(void *const pnt, const size_t len)
{
    /*#ifdef _WIN32
      SecureZeroMemory(pnt, len);
    #elif defined(HAVE_MEMSET_S)
      memset_s(pnt, (rsize_t)len, 0, (rsize_t)len);
    #elif defined(HAVE_EXPLICIT_BZERO)
      explicit_bzero(pnt, len);
    #elif defined(HAVE_EXPLICIT_MEMSET)
      explicit_memset(pnt, 0, len);
    #else*/
    volatile unsigned char *volatile pnt_ = (volatile unsigned char *volatile)pnt;
    size_t i = (size_t)0U;

    while (i < len)
    {
        pnt_[i++] = 0U;
    }
    // #endif
}

const uint8_t *fromhex(const char *str)
{
    static uint8_t buf[FROMHEX_MAXLEN];
    int len = strlen(str) / 2;
    if (len > FROMHEX_MAXLEN)
        len = FROMHEX_MAXLEN;
    for (int i = 0; i < len; i++)
    {
        uint8_t c = 0;
        if (str[i * 2] >= '0' && str[i * 2] <= '9')
            c += (str[i * 2] - '0') << 4;
        if ((str[i * 2] & ~0x20) >= 'A' && (str[i * 2] & ~0x20) <= 'F')
            c += (10 + (str[i * 2] & ~0x20) - 'A') << 4;
        if (str[i * 2 + 1] >= '0' && str[i * 2 + 1] <= '9')
            c += (str[i * 2 + 1] - '0');
        if ((str[i * 2 + 1] & ~0x20) >= 'A' && (str[i * 2 + 1] & ~0x20) <= 'F')
            c += (10 + (str[i * 2 + 1] & ~0x20) - 'A');
        buf[i] = c;
    }
    return buf;
}

void tohexprint(char *hexbuf, uint8_t *str, int strlen)
{
    // char hexbuf[strlen];
    for (int i = 0; i < strlen / 2; i++)
    {
        sprintf(&hexbuf[2 * i], "%02X", str[i]);
    }
    hexbuf[strlen - 2] = '\0';
}

size_t toHex(const uint8_t *array, size_t arraySize, char *output, size_t outputSize)
{
    if (array == NULL || output == NULL)
    {
        return 0;
    }
    // uint8_t * array = (uint8_t *) arr;
    if (outputSize < 2 * arraySize)
    {
        return 0;
    }
    memzero(output, outputSize);

    for (size_t i = 0; i < arraySize; i++)
    {
        output[2 * i] = (array[i] >> 4) + '0';
        if (output[2 * i] > '9')
        {
            output[2 * i] += 'a' - '9' - 1;
        }

        output[2 * i + 1] = (array[i] & 0x0F) + '0';
        if (output[2 * i + 1] > '9')
        {
            output[2 * i + 1] += 'a' - '9' - 1;
        }
    }
    return 2 * arraySize;
}

String toHex(const uint8_t *array, size_t arraySize)
{
    if (array == NULL)
    {
        return String();
    }
    size_t outputSize = arraySize * 2 + 1;
    char *output = (char *)malloc(outputSize);
    if (output == NULL)
    {
        return String();
    }

    toHex(array, arraySize, output, outputSize);

    String result(output);

    memzero(output, outputSize);
    free(output);

    return result;
}

// HardwareSerial Serial0(0);
HWCDC SerialESP;
SLIPEncodedSerial SLIPSerial(SerialESP); // for XIAO ESP32C3
// SLIPEncodedSerial SLIPSerial(Serial); // for AI Thinker ESP-C3-32S

Preferences valise; // ESP32-C3 to use NVS

void sendOSCMessage(OSCMessage &resp_msg)
{
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
    delay(20);
}

void setup()
{
    // begin communication via IÂ²C
    // Wire.setPins(SDA_PIN, SCL_PIN);
    // Wire.begin(SDA_PIN, SCL_PIN);

    SLIPSerial.begin(115200);
    SerialESP.setRxBufferSize(1024);
    SerialESP.setTxBufferSize(1024);
}

void routeValiseSign(OSCMessage &msg, int addressOffset)
{
    secp256k1_context *ctx = NULL;

    int res;    // to store results of function calls
    size_t len; // to store serialization lengths

    // first we need to create the context
    // this is the size of memory to be allocated
    size_t context_size = secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    // secret as hex string
    // bdb51a16eb6460ec16f84d7b6f19e20d9b9ab558fa0e9ae4bb493ef779f14055
    // import into python ecdsa code
    //
    // sk = ecdsa.SigningKey.from_string(binascii.unhexlify("bdb51a16eb6460ec16f84d7b6f19e20d9b9ab558fa0e9ae4bb493ef779f14055") ,curve=ecdsa.SECP256k1, hashfunc=hashlib.sha256)
    // private_key = sk.to_string()
    //
    // msg = hashlib.sha256(b"hello").digest().hex()
    // >>> '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'
    //
    // public_key = vk.to_string('compressed').hex()
    // >>> '02822d18bd250a11e5c86d90a801bf42443c8dca93cb62724da660b849d2514277'
    //
    //  msg = hashlib.sha256(b"hello").digest()
    // signature = sk.sign(msg,hashfunc=hashlib.sha256)
    // signature.hex()

    // some random secret key
    uint8_t secret[] = {
        0xbd, 0xb5, 0x1a, 0x16, 0xeb, 0x64, 0x60, 0xec,
        0x16, 0xf8, 0x4d, 0x7b, 0x6f, 0x19, 0xe2, 0x0d,
        0x9b, 0x9a, 0xb5, 0x58, 0xfa, 0x0e, 0x9a, 0xe4,
        0xbb, 0x49, 0x3e, 0xf7, 0x79, 0xf1, 0x40, 0x55};

    // Makes sense to check if secret key is valid.
    // It will be ok in most cases, only if secret > N it will be invalid
    res = secp256k1_ec_seckey_verify(ctx, secret);

    // computing corresponding pubkey
    secp256k1_pubkey pubkey;
    res = secp256k1_ec_pubkey_create(ctx, &pubkey, secret);

    // serialize the pubkey in compressed format
    uint8_t pub[33];
    len = sizeof(pub);
    secp256k1_ec_pubkey_serialize(ctx, pub, &len, &pubkey, SECP256K1_EC_COMPRESSED);

    // this is how you parse the pubkey
    res = secp256k1_ec_pubkey_parse(ctx, &pubkey, pub, 33);

    // hash of the string "hello"
    uint8_t hash[32] = {
        0x2c, 0xf2, 0x4d, 0xba, 0x5f, 0xb0, 0xa3, 0x0e,
        0x26, 0xe8, 0x3b, 0x2a, 0xc5, 0xb9, 0xe2, 0x9e,
        0x1b, 0x16, 0x1e, 0x5c, 0x1f, 0xa7, 0x42, 0x5e,
        0x73, 0x04, 0x33, 0x62, 0x93, 0x8b, 0x98, 0x24};
    // signing
    secp256k1_ecdsa_signature sig;

    res = secp256k1_ecdsa_sign(ctx, &sig, hash, secret, NULL, NULL);

    // uint8_t sig_secp[64];
    // res = secp256k1_ecdsa_signature_parse_compact(ctx, &sig, sig_secp);

    uint8_t der[72];
    len = sizeof(der);
    res = secp256k1_ecdsa_signature_serialize_der(ctx, der, &len, &sig);

    uint8_t compact[64];
    len = sizeof(compact);
    res = secp256k1_ecdsa_signature_serialize_compact(ctx, compact, &sig);

    // signature verification
    Serial.print("=== Signature verification ===\r\n");
    res = secp256k1_ecdsa_verify(ctx, &sig, hash, &pubkey);

    String pubStr;
    pubStr = toHex(pub, 33);

    String compactStr;
    compactStr = toHex(compact, 64);

    String derStr;
    derStr = toHex(der, 72);

    OSCMessage resp_msg("/IHW/valiseSign");
    resp_msg.add((int32_t)res);
    resp_msg.add(pubStr.c_str());
    resp_msg.add(compactStr.c_str());
    resp_msg.add(derStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

/**
 * Generate a mnemonic phrase and derive a seed, store both in memory
 *
 * @return Generated '0' or '1' string for failure or success Sending over OSC as string
 */

void routeValiseMnemonicSeedInit(OSCMessage &msg, int addressOffset)
{
    /* mnemonic stays unknown
       has to init menmonic and has to init seed
       cause, the seed is rquired for almost all bip32 calls
    */
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];

    valise.begin("vault", false);
    const char *mnemonic = "focus nature unfair swap kingdom supply weather piano fine just brief maximum federal nature goat cash crystal rally response joy unique drum merit surprise";
    valise.putString("valise_mnemonic", mnemonic);
    valise.end();

    valise.begin("vault", false);
    // converting recovery phrase to bytes
    // we have to consider which default passphrase we are going to use.
    res = bip39_mnemonic_to_seed(mnemonic, "trustanchor", bytes_out, sizeof(bytes_out), &len);
    valise.putString("valise_seed", (const char *)bytes_out);
    valise.end();

    OSCMessage resp_msg("/valiseMnemonicSeedInit");
    resp_msg.add("1");

    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

/**
 * Store the mnemonic phrase inside the trust anchor's memory
 *
 * @param String(0) The mnemonic phrase.
 * @return  Generated '0' or '1' string for failure or success Sending over OSC as string

 */
void routeValiseMnemonicSet(OSCMessage &msg, int addressOffset)
{
    valise.begin("vault", false);

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char char_mnemonic[length];
        msg.getString(0, char_mnemonic, length);

        valise.putString("valise_mnemonic", char_mnemonic);
    }

    valise.end();

    OSCMessage resp_msg("/valiseMnemonicSet");
    resp_msg.add("1");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

/**
 * Get the mnemonic phrase from the trust anchor's memory
 *
 * @return The stored menmonic. Sending over OSC as string
.
 */
void routeValiseMnemonicGet(OSCMessage &msg, int addressOffset)
{
    valise.begin("vault", false);

    String valise_mnemonic = valise.getString("valise_mnemonic", "");

    valise.end();

    OSCMessage resp_msg("/valiseMnemonicGet");
    resp_msg.add(valise_mnemonic.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

/**
 * Store the base seed inside the trust anchor's memory
 *
 * @param String(0) The base seed.
 * @param String(2) empty string for future use
 * @return  Generated '0' or '1' string for failure or success. Sending over OSC as string

 */
void routeValiseSeedSet(OSCMessage &msg, int addressOffset)
{
    int res;

    char char_seed[129];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, char_seed, length);
    }

    valise.begin("vault", false);
    valise.putString("valise_seed", (const char *)char_seed);
    valise.end();

    OSCMessage resp_msg("/valiseSeedSet");
    resp_msg.add("1");

    sendOSCMessage(resp_msg);

    resp_msg.empty();
    delay(20);
}

/**
 * Get the base seed from the trust anchor's memory
 *
 * @param String(0) empty string for future use
 * @return The stored base seed. Sending over OSC as string
.
 */
void routeValiseSeedGet(OSCMessage &msg, int addressOffset)
{
    valise.begin("vault", false);
    String valise_seed = valise.getString("valise_seed", "");
    valise.end();

    OSCMessage resp_msg("/valiseSeedGet");
    resp_msg.add(valise_seed.c_str());
    // resp_msg.add("hallo");
    // resp_msg.add(valise_seed);

    sendOSCMessage(resp_msg);

    resp_msg.empty();
    delay(20);
}

void routeWallyInit(OSCMessage &msg, int addressOffset)
{
    wally_init(0x00);

    OSCMessage resp_msg("/wallyInit");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyCleanup(OSCMessage &msg, int addressOffset)
{
    wally_cleanup(0x00);

    OSCMessage resp_msg("/wallyCleanup");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyGetSecpContext(OSCMessage &msg, int addressOffset)
{
    secp256k1_context_struct *ctxStrct;
    wally_get_secp_context();

    OSCMessage resp_msg("/wallyGetSecpContext");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyGetNewSecpContext(OSCMessage &msg, int addressOffset)
{
    secp256k1_context_struct *ctxStrct;
    // wally_get_new_secp_context();

    OSCMessage resp_msg("/wallyGetNewSecpContext");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallySecpContextFree(OSCMessage &msg, int addressOffset)
{
    secp256k1_context_struct *ctxStrct;
    // wally_secp_context_free(ctxStrct);

    OSCMessage resp_msg("/wallySecpContextFree");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyBZero(OSCMessage &msg, int addressOffset)
{
    char *bytes;
    size_t len;
    wally_bzero(bytes, len);

    OSCMessage resp_msg("/wallyBZero");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyFreeString(OSCMessage &msg, int addressOffset)
{
    char *str;
    wally_free_string(str);

    OSCMessage resp_msg("/wallyBZero");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallySecpRandomize(OSCMessage &msg, int addressOffset)
{
    unsigned char *bytes;
    size_t len;
    wally_secp_randomize(bytes, len);

    OSCMessage resp_msg("/wallyBZero");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

/* ----------------------------------------------------------------*/
/* Crypto functions                                                */
/* ----------------------------------------------------------------*/

/* part of documentation but deprecated */
/* void routeWallyEcSigFromBytesLen(OSCMessage &msg, int addressOffset)
{
  int res;
  //uint8_t priv_key[33] = "7BC81198140916367B5CED9BADA28C37";
  uint8_t priv_key[33];
  size_t priv_key_len;
  // uint8_t hash_key[33] = "C99A85979AD295811330C5689C730250";
  uint8_t hash_key[33];
  size_t hash_key_len;
  uint32_t flags;
  size_t* len;

  priv_key_len = 32;
  hash_key_len = 32;
  int length;

  if(msg.isString(0))
  {
      length=msg.getDataLength(0);
      msg.getString(0, (char*)priv_key,length);
  }

  if(msg.isString(2))
  {
      length=msg.getDataLength(2);
      msg.getString(2, (char*)hash_key,length);
  }


  res = wally_ec_sig_from_bytes_len(
            (uint8_t*)priv_key,
            priv_key_len,
            (uint8_t*)hash_key,
            hash_key_len,
            EC_FLAG_ECDSA,
            (unsigned char*)len
        );

  OSCMessage resp_msg("/IHW/wallyEcSigFromBytesLen");
  resp_msg.add(len);

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket();
  resp_msg.empty();
} */

void routeWallyEcSigFromBytes(OSCMessage &msg, int addressOffset)
{
    int res;

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /* Private keys created on the trust anchor are starting with 0x00 as prefix*/
    /* Therefore the leading HEX 0x00 has to be dropped before signing          */
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    uint8_t priv_key[33];
    char char_priv_key[67]; // has to be inside the msg.isString() check ...

    uint8_t hash_key[32];
    char char_hash_key[65]; // has to be inside the msg.isString() check ...

    uint8_t bytes_out[64];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, char_priv_key, length);
    }
    if (msg.isString(2))
    {
        int length = msg.getDataLength(2);
        msg.getString(2, char_hash_key, length);
    }

    memcpy(priv_key,
           fromhex((const char *)char_priv_key),
           33);
    memcpy(hash_key,
           fromhex((const char *)char_hash_key),
           32);

    res = wally_ec_sig_from_bytes(
        priv_key + 1, /* first byte of priv_key is 0x00 */
        32,
        hash_key,
        32,
        EC_FLAG_ECDSA,
        bytes_out,
        64);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(bytes_out, 64);

    OSCMessage resp_msg("/IHW/wallyEcSigFromBytes");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(char_priv_key);
    resp_msg.add(char_hash_key);

    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(char_priv_key);
    wally_free_string(char_hash_key);
}

void routeWallyEcSigNormalize(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t sig[64];
    char char_sig[129];

    uint8_t bytes_out[64];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, char_sig, length);
    }

    memcpy(sig,
           fromhex(char_sig),
           64);

    res = wally_ec_sig_normalize(
        sig,
        EC_SIGNATURE_LEN,
        bytes_out,
        EC_SIGNATURE_LEN);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(bytes_out, 64);

    OSCMessage resp_msg("/IHW/wallyEcSigNormalize");
    resp_msg.add(hexStr.c_str());
    // resp_msg.add("test message");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyEcSigToDer(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t sig[64];

    char str_sig[129];

    uint8_t der[73];

    size_t len;

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, str_sig, length);
    }

    memcpy(sig,
           fromhex(str_sig),
           64);

    res = wally_ec_sig_to_der(
        sig,
        EC_SIGNATURE_LEN,
        der,
        EC_SIGNATURE_DER_MAX_LEN,
        &len);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(der, EC_SIGNATURE_DER_MAX_LEN);

    OSCMessage resp_msg("/IHW/wallyEcSigToDer");
    resp_msg.add(hexStr.c_str());
    // resp_msg.add("test message");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyEcSigFromDer(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t der[72];

    char str_der[145];

    uint8_t sig[64];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, (char *)str_der, length);
    };
    memcpy(der,
           fromhex(str_der),
           72);

    res = wally_ec_sig_from_der(
        der,
        72,
        sig,
        64);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(sig, 64);

    OSCMessage resp_msg("/IHW/wallyEcSigFromDer");
    resp_msg.add(hexStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

uint8_t pub_key_buffer[33];
uint8_t hash_buffer[32];

void routeWallyEcSigVerify2(OSCMessage &msg, int addressOffset)
{
    int res;
    int ret;

    size_t pub_len;
    size_t hash_len;
    size_t sig_len;

    pub_len = 33;
    hash_len = 32;
    sig_len = 64;

    // uint8_t pub_key[33];
    char str_pub_key[] = "02822d18bd250a11e5c86d90a801bf42443c8dca93cb62724da660b849d2514277";

    uint8_t pub_key[] =
        {
            0x02, 0x82, 0x2d, 0x18, 0xbd, 0x25, 0x0a, 0x11,
            0xe5, 0xc8, 0x6d, 0x90, 0xa8, 0x01, 0xbf, 0x42,
            0x44, 0x3c, 0x8d, 0xca, 0x93, 0xcb, 0x62, 0x72,
            0x4d, 0xa6, 0x60, 0xb8, 0x49, 0xd2, 0x51, 0x42, 0x77};

    // 02822d18bd250a11e5c86d90a801bf42443c8dca93cb62724da660b849d2514277
    // 02822d18bd250a11e5c86d90a801bf42443c8dca93cb62724da660b849d2514277

    // uint8_t hash[32];
    // char str_hash[] = "3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392";

    uint8_t hash[] =
        {
            0x33, 0x38, 0xbe, 0x69, 0x4f, 0x50, 0xc5, 0xf3,
            0x38, 0x81, 0x49, 0x86, 0xcd, 0xf0, 0x68, 0x64,
            0x53, 0xa8, 0x88, 0xb8, 0x4f, 0x42, 0x4d, 0x79,
            0x2a, 0xf4, 0xb9, 0x20, 0x23, 0x98, 0xf3, 0x92};

    // 3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392
    // 3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392

    // uint8_t sig[64];
    char str_sig[] = "7ed5651904434654f5a68cc079e3ef643266af00af0d81459d7a0b58d5d803885fa8865f987e8b25bf1ac099f0fe31598bf94b8913fcaea7e03d8feafa92323c";

    // 7ed5651904434654f5a68cc079e3ef643266af00af0d81459d7a0b58d5d803885fa8865f987e8b25bf1ac099f0fe31598bf94b8913fcaea7e03d8feafa92323c
    // 7ed5651904434654f5a68cc079e3ef643266af00af0d81459d7a0b58d5d803885fa8865f987e8b25bf1ac099f0fe31598bf94b8913fcaea7e03d8feafa92323c

    uint8_t sig[] =
        {
            0x7e, 0xd5, 0x65, 0x19, 0x04, 0x43, 0x46, 0x54,
            0xf5, 0xa6, 0x8c, 0xc0, 0x79, 0xe3, 0xef, 0x64,
            0x32, 0x66, 0xaf, 0x00, 0xaf, 0x0d, 0x81, 0x45,
            0x9d, 0x7a, 0x0b, 0x58, 0xd5, 0xd8, 0x03, 0x88,
            0x5f, 0xa8, 0x86, 0x5f, 0x98, 0x7e, 0x8b, 0x25,
            0xbf, 0x1a, 0xc0, 0x99, 0xf0, 0xfe, 0x31, 0x59,
            0x8b, 0xf9, 0x4b, 0x89, 0x13, 0xfc, 0xae, 0xa7,
            0xe0, 0x3d, 0x8f, 0xea, 0xfa, 0x92, 0x32, 0x3c};

    // memset(pub_key,0x00,33);
    // memset(hash,0x00,32);
    // memset(sig,0x00,64);

    // memcpy(pub_key, fromhex(str_pub_key), 33);
    // memcpy(hash, fromhex(str_hash), 32);
    // memcpy(sig, fromhex(str_sig),  64);

    ret = wally_ec_public_key_verify(pub_key, 33);

    res = wally_ec_sig_verify(
        (const unsigned char *)pub_key,
        pub_len, // EC_PUBLIC_KEY_LEN,
        (const unsigned char *)hash,
        hash_len, // EC_MESSAGE_HASH_LEN,
        EC_FLAG_ECDSA,
        (const unsigned char *)sig,
        sig_len // EC_SIGNATURE_LEN
    );

    String hexStr;
    hexStr = toHex(sig, 64);
    String hexStr2;
    hexStr2 = toHex(pub_key, 33);
    String hexStr3;
    hexStr3 = toHex(hash, 32);

    OSCMessage resp_msg("/IHW/wallyEcSigVerify2");
    resp_msg.add((int32_t)ret);
    resp_msg.add((int32_t)res);
    resp_msg.add(hexStr3.c_str());
    resp_msg.add(hexStr2.c_str());
    resp_msg.add(hexStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeValiseCborEcho(OSCMessage &msg, int addressOffset)
{

    OSCMessage msg2("/cbor/echo");
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes(NULL, se_rnd, sizeof(se_rnd), &phrase);

    msg2.add(
        "d08355a20101055001010101010101010101010101010101a10458246d65726961646f632e6272616e64796275636b406275636b6c616e642e6578616d706c655820c4af85ac4a5134931993ec0a1863a6e8c66ef4c9ac16315ee6fecd9b2e1c79a1");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg2.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void routeWallyEcSigToPublicKey(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t pub_key[33];

    uint8_t hash[32];
    char str_hash[65];

    uint8_t sig[64];
    char str_sig[129];

    size_t len;

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, (char *)str_hash, length);
    };
    memcpy(hash,
           fromhex(str_hash),
           32);

    if (msg.isString(1))
    {
        int length = msg.getDataLength(2);
        msg.getString(1, (char *)str_sig, length);
    }
    memcpy(sig,
           fromhex(str_sig),
           64);

    res = wally_ec_sig_to_public_key(
        hash,
        32,
        sig,
        64,
        pub_key,
        len);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(pub_key, 33);

    OSCMessage resp_msg("/IHW/wallyEcSigToPublicKey");
    resp_msg.add(hexStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyFormatBitcoinMessage(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t btc_msg[512];
    char str_btc_msg[1025];

    uint8_t btc_msg_hash[32];

    int *len;
    size_t *written;

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, (char *)str_btc_msg, length);
        len = &length;
    };

    memcpy(btc_msg,
           fromhex(str_btc_msg),
           *len);

    res = wally_format_bitcoin_message(
        btc_msg, *len,
        BITCOIN_MESSAGE_FLAG_HASH,
        btc_msg_hash, 32,
        written);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(btc_msg_hash, 32);

    OSCMessage resp_msg("/IHW/wallyFormatBitcoinMessage");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(str_btc_msg);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyEcdh(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t pub_key[33];
    char str_pub_key[66];

    uint8_t priv_key[32];
    char str_priv_key[64];

    uint8_t shared_secret[32];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, str_pub_key, length);
    };

    memcpy(pub_key,
           fromhex(str_pub_key),
           33);

    if (msg.isString(1))
    {
        int length = msg.getDataLength(1);
        msg.getString(1, str_priv_key, length);
    };

    memcpy(priv_key,
           fromhex(str_priv_key),
           32);

    res = wally_ecdh(
        (const unsigned char *)pub_key, EC_PUBLIC_KEY_LEN,
        (const unsigned char *)priv_key, EC_PRIVATE_KEY_LEN,
        (unsigned char *)shared_secret, SHA256_LEN);

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(shared_secret, 32);

    String hexStrPub;
    hexStrPub = toHex(pub_key, 33);

    String hexStrPriv;
    hexStrPriv = toHex(priv_key, 32);

    OSCMessage resp_msg("/IHW/wallyEcdh");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(hexStrPub.c_str());
    resp_msg.add(hexStrPriv.c_str());

    // resp_msg.add(str_pub_key);
    // resp_msg.add(str_priv_key);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

/*void routeWallyS2cSigFromBytes(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t priv_key[32];
  char str_priv_key[66];  // /* EC_PRIVATE_KEY_LEN - 32

  uint8_t msg_hash[32];
  char str_msg_hash[66]; // /* EC_MESSAGE_HASH_LEN - 32

  uint8_t s2c_data[32];
  char str_s2c_data[66]; // /* WALLY_S2C_DATA_LEN - 32

  // /* EC_FLAG_ECDSA

  uint8_t s2c_opening_out[33];
  char str_s2c_opening_out[68]; // /* WALLY_S2C_OPENING_LEN - 32

  uint8_t sig[64]; // /* EC_SIGNATURE_LEN - 64

  int len = 64;

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_priv_key, length);
  };

  memcpy(priv_key,
        fromhex(str_priv_key),
        32
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, (char*)str_msg_hash, length);
  };

  memcpy(msg_hash,
        fromhex(str_msg_hash),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_s2c_data, length);
  };

  memcpy(s2c_data,
        fromhex(str_s2c_data),
        32
  );

  res = wally_s2c_sig_from_bytes(
      priv_key, 32,
      msg_hash, 32,
      s2c_data, 32,
      EC_FLAG_ECDSA,
      s2c_opening_out, 33,
      sig, 64
  )

  // /* Requirement by Arduino to stream strings back to requestor
  String hexStrS2cOpeningOut;
  hexStrS2cOpeningOut = toHex(s2c_opening_out, 33);

  String hexStrSig;
  hexStrSig = toHex(sig, 64);


  OSCMessage resp_msg("/IHW/wallyS2cSigFromBytes");
  resp_msg.add(hexStrS2cOpeningOut.c_str());
  resp_msg.add(hexStrSig.c_str());

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket();
  resp_msg.empty();

} */

/* void routeWallyS2cCommitmentVerify(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t sig[64]; // /* EC_SIGNATURE_LEN - 64
  char str_sig[128];

  uint8_t s2c_data[32];
  char str_s2c_data[66]; // /* WALLY_S2C_DATA_LEN - 32

  uint8_t s2c_opening_out[33];
  char str_s2c_opening_out[68]; // /* WALLY_S2C_OPENING_LEN - 32

  // /* EC_FLAG_ECDSA

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_sig, length);
  };

  memcpy(sig,
        fromhex(str_sig),
        64
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, (char*)str_s2c_data, length);
  };

  memcpy(s2c_data,
        fromhex(str_s2c_data),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_s2c_opening_out, length);
  };

  memcpy(s2c_opening_out,
        fromhex(str_s2c_opening_out),
        33
  );

  res = wally_s2c_commitment_verify(
      sig, 64,
      s2c_data, 32,
      s2c_opening_out, 33,
      EC_FLAG_ECDSA
  )

  OSCMessage resp_msg("/IHW/wallyCommitmentVerify");
  resp_msg.add("True");

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket();
  resp_msg.empty();

} */

/* ----------------------------------------------------------------*/
/* wally bip39 functions                                           */
/* ----------------------------------------------------------------*/

/**
 * Get all te languages available to create mnemonic phrases
 *
 * @param String(0) empty string for future use
 * @return A list of all languages, available. Sending over OSC as string
.
 */
void routeBip39GetLanguages(OSCMessage &msg, int addressOffset)
{
    int res;
    char *output = NULL;

    res = bip39_get_languages(&output);

    OSCMessage resp_msg("/bip39GetLanguages");
    resp_msg.add(output);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(output);
}

/**
 * Get all the languages available to create mnemonic phrases
 *
 * @param String(0) The language identifier. 'en es fr it jp zhs zht'
 * @param String(1) empty string for future use
 * @return A list of all languages, available. Sending over OSC as string
.
 */
void routeBip39GetWordlist(OSCMessage &msg, int addressOffset)
{
    int res;

    if (msg.isString(0))
    {
        struct words *output;
        int length = msg.getDataLength(0);
        char lang[length];
        msg.getString(0, lang, length);

        res = bip39_get_wordlist(lang, &output);

        OSCMessage resp_msg("/bip39GetWordlist");
        resp_msg.add(output);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        resp_msg.empty();
    }
}

/**
 * Get all the nth word of the wordlist for mnemonic phrases
 *
 * @param String(0) The language identifier. 'en es fr it jp zhs zht'
 * @param String(1) The nth word out of the wordlist
 * @param String(2) empty string for future use
 * @return The nth word in the chosen language out of the wordlist. Sending over OSC as string
.
 */
void routeBip39GetWord(OSCMessage &msg, int addressOffset)
{
    int res;
    struct words *w;

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char lang[length];
        msg.getString(0, lang, length);
        res = bip39_get_wordlist(lang, &w);
    }

    if (msg.isInt(1))
    {
        // don't forget problem with endianess
        char *output;
        int nth_word = msg.getInt(1);
        res = bip39_get_word(w, nth_word, &output);

        OSCMessage resp_msg("/bip39GetNthWord");

        char str_nth_word[10];
        sprintf(str_nth_word, "%d", nth_word);
        resp_msg.add(str_nth_word);
        resp_msg.add(output);

        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        resp_msg.empty();

        wally_free_string(output);
    }
}

void routeBip39NumberBouncer(OSCMessage &msg, int addressOffset)
{
    int res;

    if (msg.isInt(0))
    {
        int nth_word = msg.getInt(0);

        OSCMessage resp_msg("/bip39GetNumberBouncer");

        char str_nth_word[10];
        sprintf(str_nth_word, "%d", nth_word);
        resp_msg.add((int32_t)nth_word);

        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        resp_msg.empty();
    }
}

/**
 * Validate the checksum in a mnemonic phrases
 *
 * @param String(0) The language identifier. 'en es fr it jp zhs zht'
 * @param String(1) The mnemonic phrase to validate
 * @param String(2) empty string for future use
 * @return Error Code. Sending over OSC as string
.
 */
void routeBip39MnemonicValidate(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/IHW/Bip39MnemonicValidate");

    struct words *w;

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char lang[length];
        msg.getString(0, lang, length);
        res = bip39_get_wordlist(lang, &w);
    }

    if (msg.isString(1))
    {
        int length = msg.getDataLength(1);
        char phrase[length];
        msg.getString(1, phrase, length);

        res = bip39_mnemonic_validate(w, phrase);

        resp_msg.add((int32_t)res);
    }

    sendOSCMessage(resp_msg);
}

void routeBip39MnemonicToSeed(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char phrase[length];
        msg.getString(0, phrase, length);

        // converting recovery phrase to bytes
        // we have to consider which default passphrase we are going to use.
        res = bip39_mnemonic_to_seed(phrase, "trustanchor", bytes_out, sizeof(bytes_out), &len);
        // res = bip39_mnemonic_to_bytes(NULL, phrase, bytes_out, sizeof(bytes_out), &len);
    }

    String hexStr;
    hexStr = toHex(bytes_out, 64);

    OSCMessage resp_msg("/bip39MnemonicToSeed");
    resp_msg.add(hexStr.c_str());

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    delay(20);
}

void routeBip39MnemonicToSeed512(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char phrase[length];
        msg.getString(0, phrase, length);

        // converting recovery phrase to bytes
        // we have to consider which default passphrase we are going to use.
        res = bip39_mnemonic_to_seed(phrase, "trustanchor", bytes_out, sizeof(bytes_out), &len);
        // res = bip39_mnemonic_to_bytes(NULL, phrase, bytes_out, sizeof(bytes_out), &len);
    }

    String hexStr;
    hexStr = toHex(bytes_out, 64);

    OSCMessage resp_msg("/bip39MnemonicToSeed");
    resp_msg.add(hexStr.c_str());

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    delay(20);
}

void routeBip39Mnemonic(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes(NULL, se_rnd, sizeof(se_rnd), &phrase);

    msg.add(phrase);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void routeEntropy(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    // const char *seed;
    // seed = toHex(se_rnd, 32).c_str();

    char seed[32];

    memset(seed, '\0', sizeof(seed));
    for (int i = 0; i < 31; i++)
    {
        static char tmp[4] = {};
        sprintf(tmp, "%02X", se_rnd[i]);
        strcpy(seed + i, tmp);
    }

    // msg.add("2573548DF4251F3048ABA137EFEEC11E59C0738D47C88B46462EDE80BEFFA2CA");

    msg.add(seed);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void routeBip39MnemonicToPrivateKey(OSCMessage &msg, int addressOffset)
{
    int res;

    char phrase[512];
    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, phrase, length);
    }

    // Convert mnemonic to seed
    uint8_t seed[BIP39_SEED_LEN_512];
    size_t seed_len;
    res = bip39_mnemonic_to_seed(phrase, "my password", seed, sizeof(seed), &seed_len);
    // Generate BIP32 master key from seed
    res = bip32_key_from_seed(seed, sizeof(seed), BIP32_VER_MAIN_PRIVATE, 0, &root);

    // // Clear seed from memory for security
    memset(seed, 0, sizeof(seed_len));

    // // // Convert master_key to base58 string
    char *base58_master_key = NULL;
    res = bip32_key_to_base58(&root, BIP32_FLAG_KEY_PRIVATE, &base58_master_key);

    String hexStr;
    hexStr = toHex(root.priv_key, 33);

    // Send the result back
    OSCMessage resp_msg("/IHW/BipMnemonicToPrivateKey");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(base58_master_key);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    // wally_free_string(base58_master_key);
    // wally_free_string(phrase);
}

/**
 * Generate key from given Seed
 *
 * @param string(0) seed in String type
 * @param int(1) <optional> key type. default is BIP32_VER_MAIN_PRIVATE
 * @return Generated key. Sending over OSC as string
 */
void routeBip32KeyFromSeed(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t seed[64];
    char char_seed[129];

    OSCMessage resp_msg("/bip32KeyFromSeed");

    if (msg.isString(0))
    {
        // Get seed
        size_t len = msg.getDataLength(0);
        msg.getString(0, char_seed, len);
        if (len != 0)
        {
            memcpy(
                seed,
                fromhex((const char *)char_seed),
                64);
        }
        else
        {
            valise.begin("vault", false);
            String valise_seed = valise.getString("valise_seed", "");
            valise.end();

            memcpy(
                seed,
                fromhex((const char *)valise_seed.c_str()),
                64);
        }

        /* Check if the user *indicate flag */
        int flag = BIP32_VER_MAIN_PRIVATE;
        if (msg.isInt(1))
        {
            switch (msg.getInt(1))
            {
            // case 0 and case 2, public keys are not supported.
            case 0:
                flag = BIP32_VER_MAIN_PUBLIC;
                break;

            case 1:
                flag = BIP32_VER_MAIN_PRIVATE;
                break;

            case 2:
                flag = BIP32_VER_TEST_PUBLIC;
                break;

            case 3:
                flag = BIP32_VER_TEST_PRIVATE;
                break;

            default:
                flag = BIP32_VER_MAIN_PRIVATE;
                break;
            }
        }

        ext_key *hdKey;
        res = bip32_key_from_seed_alloc(seed, sizeof(seed), flag, 0, &hdKey);

        /*String hexStrChainCode;
        hexStrChainCode = toHex((const uint8_t*)hdKey->chain_code,32);
        resp_msg.add(hexStrChainCode.c_str());

        String hexStrChildNum;
        hexStrChildNum = toHex((const uint8_t*)hdKey->child_num,4);
        resp_msg.add(hexStrChildNum.c_str());
        */

        // String hexStrDepth;
        // hexStrDepth = toHex((const uint8_t*)hdKey->depth,2);
        // resp_msg.add(hexStrDepth.c_str());

        /* String hexStrHash160;
        hexStrHash160 = toHex((const uint8_t*)hdKey->hash160,20);
        resp_msg.add(hexStrHash160.c_str());

        String hexStrPad1;
        hexStrPad1 = toHex((const uint8_t*)hdKey->pad1,10);
        resp_msg.add(hexStrPad1.c_str());

        String hexStrPad2;
        hexStrPad2 = toHex((const uint8_t*)hdKey->pad2,3);
        resp_msg.add(hexStrPad2.c_str());

        String hexStrParent160;
        hexStrParent160 = toHex((const uint8_t*)hdKey->parent160,20);
        resp_msg.add(hexStrParent160.c_str());
        */

        String hexStrPrivKey;
        hexStrPrivKey = toHex((const uint8_t *)hdKey->priv_key, 33);
        resp_msg.add(hexStrPrivKey.c_str());

        String hexStrPubKey;
        hexStrPubKey = toHex((const uint8_t *)hdKey->pub_key, 33);
        resp_msg.add(hexStrPubKey.c_str());

        /*String hexStrVersion;
        hexStrVersion = toHex((const uint8_t*)hdKey->version,4);
        resp_msg.add(hexStrVersion.c_str());
        */

        bip32_key_free(hdKey);
    }
    else
        resp_msg.add("ERROR! Couldnt get seed");

    sendOSCMessage(resp_msg);
}

void routeTrnd(OSCMessage &msg, int addressOffset)
{
    int len;

    if (msg.isInt(0))
    {
        len = msg.getInt(0);
        uint8_t se_rnd[len] = {0};
        esp_fill_random(se_rnd, len);

        char trnd[len];
        memset(trnd, '\0', sizeof(trnd));
        for (int i = 0; i < len - 1; i++)
        {
            static char tmp[4] = {};
            sprintf(tmp, "%02X", se_rnd[i]);
            strcpy(trnd + i, tmp);
        }

        msg.add(trnd);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        msg.empty();
    }
}

void routeBip39MnemonicToBytes(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char phrase[length];
        msg.getString(0, phrase, length);
        // Serial.println(phrase);

        // converting recovery phrase to bytes
        res = bip39_mnemonic_to_bytes(NULL, phrase, bytes_out, sizeof(bytes_out), &len);
    }

    String hexStr;
    hexStr = toHex(bytes_out, 32);
    // Serial.println(hexStr);

    OSCMessage resp_msg("/bip39MnemonicToBytes");
    resp_msg.add(hexStr.c_str());

    sendOSCMessage(resp_msg);
    delay(20);
}

void routeBip39MnemonicFromBytes(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];
    char *phrase = NULL;

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char hexStr[length];
        msg.getString(0, hexStr, length);
        // Serial.println(hexStr);

        res = bip39_mnemonic_from_bytes(NULL, (const unsigned char *)fromhex(hexStr), 32, &phrase);
    }

    OSCMessage resp_msg("/Bip39MnemonicFromBytes");
    resp_msg.add(phrase);
    sendOSCMessage(resp_msg);

    delay(20);
}

/**
 * Generate child key from parent key and given number
 *
 * @param String(0) given base seed
 * @param int(1) num of child key. default value is 0
 * @param int(2) hardened or non-hardened 1 or 0, adds 0x8000000
 * @param int(3) <optional> network version type. default is BIP32_VER_MAIN_PRIVATE
 * @param int(4) <optional> key type. default is BIP32_FLAG_KEY_PRIVATE
 * @param String(5) empty string for future use
 * @return Generated child key. Private key raw and serialized. Sending over OSC as string
 */
void routeBip32KeyFromParent(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeyfromParent");

    char *xprv = NULL;
    char *xpub = NULL;
    uint8_t seed[BIP39_SEED_LEN_512];

    int version = BIP32_VER_MAIN_PRIVATE;
    int flag = BIP32_FLAG_KEY_PRIVATE;

    if (msg.isString(0))
    {
        // Get seed
        int lengthSeed = msg.getDataLength(0);
        char hexStrSeed[lengthSeed];
        msg.getString(0, hexStrSeed, lengthSeed);

        if (lengthSeed != 0)
        {
            memcpy(seed,
                   fromhex(hexStrSeed),
                   BIP39_SEED_LEN_512);
        }
        else
        {
            valise.begin("vault", false);
            String valise_seed = valise.getString("valise_seed", "");
            valise.end();

            memcpy(
                seed,
                fromhex((const char *)valise_seed.c_str()),
                64);
        }

        // Get child number
        size_t childNum = 0;
        // int childHardened = 1;
        if (msg.isInt(1))
        {
            if (msg.getInt(2) == 1)
            {
                childNum = msg.getInt(1) + BIP32_INITIAL_HARDENED_CHILD;
            }
            else
            {
                childNum = msg.getInt(1);
            }
        }

        // Get network version number
        if (msg.isInt(3))
        {
            switch (msg.getInt(3))
            {
            case 0:
                version = BIP32_VER_MAIN_PRIVATE;
                break;

            case 1:
                version = BIP32_VER_TEST_PRIVATE;
                break;

            default:
                version = BIP32_VER_MAIN_PRIVATE;
                break;
            }
        }

        // Get key type flag
        if (msg.isInt(4))
        {
            switch (msg.getInt(4))
            {
            case 0:
                flag = BIP32_FLAG_KEY_PRIVATE;
                break;

            case 1:
                flag = BIP32_FLAG_KEY_PUBLIC;
                break;

            default:
                flag = BIP32_FLAG_KEY_PRIVATE;
                break;
            }
        }

        ext_key derived_key_root;
        ext_key child_key_root;

        res = bip32_key_from_seed(seed, BIP32_ENTROPY_LEN_512, version, 0, &derived_key_root);
        res = bip32_key_from_parent(&derived_key_root, childNum, BIP32_FLAG_KEY_PRIVATE, &child_key_root);
        res = bip32_key_to_base58(&child_key_root, BIP32_FLAG_KEY_PRIVATE, &xprv);
        res = bip32_key_to_base58(&child_key_root, BIP32_FLAG_KEY_PUBLIC, &xpub);

        if (flag == 0)
        {
            String hexStr;
            hexStr = toHex(child_key_root.priv_key, 33);
            resp_msg.add(hexStr.c_str());
            resp_msg.add(xprv);
        }
        else
        {
            String hexStr;
            hexStr = toHex(child_key_root.pub_key, 33);
            resp_msg.add(hexStr.c_str());
            resp_msg.add(xpub);
        }
    }

    // bip32_key_free(pk);

    sendOSCMessage(resp_msg);
}

void routeBip32KeyFromParent2(OSCMessage &msg, int addressOffset)
{
    int res;

    char char_priv_key[65]; // has to be inside the msg.isString() check ...

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, char_priv_key, length);
    }

    ext_key parent_key;
    memcpy(parent_key.priv_key,
           fromhex(char_priv_key),
           32);

    uint32_t child_index = msg.getInt(2);

    // Derive child key from parent key
    ext_key child_ext_key;
    res = bip32_key_from_parent(&parent_key, child_index, BIP32_FLAG_KEY_PUBLIC, &child_ext_key);
    if (res != WALLY_OK)
    {
        // Handle the error
        Serial.println("Error: Failed to derive child key from parent key");
        return;
    }

    // Convert child_ext_key to base58 string
    char *base58_child_key = NULL;
    res = bip32_key_to_base58(&child_ext_key, BIP32_FLAG_KEY_PUBLIC, &base58_child_key);
    if (res != WALLY_OK)
    {
        // Handle the error
        Serial.println("Error: Failed to convert child key to base58");
        return;
    }

    String hexStr;
    hexStr = toHex(child_ext_key.pub_key, 33);

    // Send the result back
    OSCMessage resp_msg("/IHW/bip32KeyFromParent");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(base58_child_key);
    resp_msg.add((int32_t)child_index);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(base58_child_key);
}

/**
 * Convert key to base58 data
 *
 * @param String(0) given key as base seed
 * @param int(1) <optional> key type. default is BIP32_FLAG_KEY_PRIVATE
 * @return base58 type of serialized private or public key for given seed. Sending over OSC as string
 */
void routeBip32KeyToBase58(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeytoBase58");

    if (msg.isString(0))
    {
        // Get seed
        size_t len = msg.getDataLength(0);
        char key[len];
        msg.getString(0, key, len);

        /* Check if the user *indicate flag */
        int flag = BIP32_FLAG_KEY_PRIVATE;
        if (msg.isInt(1))
        {
            switch (msg.getInt(1))
            {
            case 0:
                flag = BIP32_FLAG_KEY_PRIVATE;
                break;

            case 1:
                flag = BIP32_FLAG_KEY_PUBLIC;
                break;

            case 2:
                flag = BIP32_FLAG_SKIP_HASH;
                break;

            case 4:
                flag = BIP32_FLAG_KEY_TWEAK_SUM;
                break;

            default:
                flag = BIP32_VER_MAIN_PRIVATE;
                break;
            }
        }

        char *xprv = NULL;
        res = bip32_key_to_base58((ext_key *)fromhex(key), flag, &xprv);

        resp_msg.add(xprv);

        wally_free_string(xprv);
    }
    else
        resp_msg.add("ERROR! Couldnt get key");

    sendOSCMessage(resp_msg);
}

/**
 * Generate child key from parent key and path
 *
 * @param String(0) given key as base seed or empty
 * @param String(1) path of child key
 * @param int(2) <optional> key type. default is BIP32_FLAG_KEY_PRIVATE
 * @return Generated child key. Private Key raw and serialized .Sending over OSC as string
 */
/*void routeBip32KeyFromParentPath(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeyfromParentPath");

    if(msg.isString(0))
    {
        // Get Parent Key
            size_t len=msg.getDataLength(0);
        char key[len];
            msg.getString(0, key, len);

        // Get Path
        std::vector<uint32_t> childPath;
        if(msg.isString(1)){
            len = msg.getDataLength(1);
            char pathString[len];
            msg.getString(1,pathString,len);
            childPath = getPath(pathString);
        }*/

/* Check if the user *indicate flag */
/*int flag = BIP32_FLAG_KEY_PRIVATE;
if(msg.isInt(2)){
    switch ( msg.getInt(2))
    {
    case 0:
        flag = BIP32_FLAG_KEY_PRIVATE;
        break;

    case 1:
        flag = BIP32_FLAG_KEY_PUBLIC;
        break;

    case 2:
        flag = BIP32_FLAG_SKIP_HASH;
        break;

    case 4:
        flag = BIP32_FLAG_KEY_TWEAK_SUM;
        break;

    default:
        flag = BIP32_VER_MAIN_PRIVATE;
        break;
    }
}

ext_key *pk = (ext_key*)fromhex(key);
if(childPath.size())
    res = bip32_key_from_parent_path_alloc((ext_key*)fromhex(key), childPath.data(), childPath.size(), flag, &pk);

String hexStr;
hexStr = toHex((uint8_t*)pk, sizeof(ext_key));
resp_msg.add(hexStr.c_str());

if(childPath.size())
    bip32_key_free(pk);
}else
resp_msg.add("ERROR! Couldnt get key");

sendOSCMessage(resp_msg);
}*/

/**
 * Generate child key from parent key and path
 *
 * @param String(0) given key as base seed or empty
 * @param String(1) path of child key
 * @param int(2) <optional> Bip-32 entropy. default is BIP39_SEED_LEN_512;
 * @param int(3) Network version type. Main or testnet
 * @param int(4) <optional> key type. default is BIP32_FLAG_KEY_PRIVATE
 * @return Generated child key. Private Key raw and serialized .Sending over OSC as string
 */
void routeBip32KeyFromParentPathString(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;

    OSCMessage resp_msg("/bip32KeyFromParentPathString");

    char *xprv = NULL;
    char *xpub = NULL;
    uint8_t seed[BIP39_SEED_LEN_512];

    int version = BIP32_VER_MAIN_PRIVATE;
    int flag = BIP32_FLAG_KEY_PRIVATE;

    // Get seed
    if (msg.isString(0)) // logical 'AND' for msg.isString(0) and msg.isString(1)
    {
        int lengthSeed = msg.getDataLength(0);
        char hexStrSeed[lengthSeed];
        msg.getString(0, hexStrSeed, lengthSeed);
        if (lengthSeed != 0)
        {
            memcpy(seed,
                   fromhex(hexStrSeed),
                   BIP39_SEED_LEN_512);
        }
        else
        {
            valise.begin("vault", false);
            String valise_seed = valise.getString("valise_seed", "");
            valise.end();

            memcpy(
                seed,
                fromhex((const char *)valise_seed.c_str()),
                64);
        }
    }

    // Get Path
    std::vector<uint32_t> childPath;
    if (msg.isString(1))
    {
        len = msg.getDataLength(1);
        char pathString[len];
        msg.getString(1, pathString, len);
        childPath = getPath(pathString);
    }

    // Get network version number
    if (msg.isInt(3))
    {
        switch (msg.getInt(3))
        {
        case 0:
            version = BIP32_VER_MAIN_PRIVATE;
            break;

        case 1:
            version = BIP32_VER_TEST_PRIVATE;
            break;

        default:
            version = BIP32_VER_MAIN_PRIVATE;
            break;
        }
    }

    // Get key type flag
    if (msg.isInt(4))
    {
        switch (msg.getInt(4))
        {
        case 0:
            flag = BIP32_FLAG_KEY_PRIVATE;
            break;

        case 1:
            flag = BIP32_FLAG_KEY_PUBLIC;
            break;

        default:
            flag = BIP32_FLAG_KEY_PRIVATE;
            break;
        }
    }

    ext_key derived_key_root;
    ext_key child_key_root;

    res = bip32_key_from_seed(seed, BIP32_ENTROPY_LEN_512, version, 0, &derived_key_root);

    res = bip32_key_from_parent_path(&derived_key_root, childPath.data(), childPath.size(), BIP32_FLAG_KEY_PRIVATE,
                                     &child_key_root);

    res = bip32_key_to_base58(&child_key_root, BIP32_FLAG_KEY_PRIVATE, &xprv);
    res = bip32_key_to_base58(&child_key_root, BIP32_FLAG_KEY_PUBLIC, &xpub);

    if (flag == 0)
    {
        String hexStr;
        hexStr = toHex(child_key_root.priv_key, 33);
        resp_msg.add(hexStr.c_str());
        resp_msg.add(xprv);
    }
    else
    {
        String hexStr;
        hexStr = toHex(child_key_root.pub_key, 33);
        resp_msg.add(hexStr.c_str());
        resp_msg.add(xpub);
    }

    /*
    derive_key_out = ext_key ( )
    # ret = bip32_key_from_parent ( master, x, FLAG_KEY_PRIVATE, derive_key_out)
    ret = bip32_key_from_parent_path_str_n(master, 'm/0h/0h/'+str(x)+'h', len('m/0h/0h/'+str(x)+'h'), 0, FLAG_KEY_PRIVATE, derive_key_out)
    _,wif = wally_wif_from_bytes ( derive_key_out.priv_key, 32, 0xef, 0)
    derived_keys.append(wif)
    */

    sendOSCMessage(resp_msg);
}

/**
 * Serialize an extended key to memory using BIP32 format.
 *
 * @param String(0) given key as base seed
 * @param String(1) intended derivation path
 * @param int(2) <optional> network version type. default is BIP32_VER_MAIN_PRIVATE
 * @param int(3) <optional> key type. default is BIP32_FLAG_KEY_PRIVATE
 * @param String(4) empty string for future use
 * @return serialized key
 */
void routeBip32KeySerialize(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeySerialize");

    char *xprv = NULL;
    char *xpub = NULL;
    uint8_t seed[BIP39_SEED_LEN_512];

    int version = BIP32_VER_MAIN_PRIVATE;
    int flag = BIP32_FLAG_KEY_PRIVATE;

    // Get seed
    if (msg.isString(0)) // logical 'AND' for msg.isString(0) and msg.isString(1)
    {
        int lengthSeed = msg.getDataLength(0);
        char hexStrSeed[lengthSeed];
        msg.getString(0, hexStrSeed, lengthSeed);
        if (lengthSeed != 0)
        {
            memcpy(seed,
                   fromhex(hexStrSeed),
                   BIP39_SEED_LEN_512);
        }
        else
        {
            valise.begin("vault", false);
            String valise_seed = valise.getString("valise_seed", "");
            valise.end();

            memcpy(
                seed,
                fromhex((const char *)valise_seed.c_str()),
                64);
        }
    }

    // Get Path
    std::vector<uint32_t> childPath;
    if (msg.isString(1))
    {
        len = msg.getDataLength(1);
        char pathString[len];
        msg.getString(1, pathString, len);
        childPath = getPath(pathString);
    }

    // Get network version number
    if (msg.isInt(3))
    {
        switch (msg.getInt(3))
        {
        case 0:
            version = BIP32_VER_MAIN_PRIVATE;
            break;

        case 1:
            version = BIP32_VER_TEST_PRIVATE;
            break;

        default:
            version = BIP32_VER_MAIN_PRIVATE;
            break;
        }
    }

    // Get key type flag
    if (msg.isInt(4))
    {
        switch (msg.getInt(4))
        {
        case 0:
            flag = BIP32_FLAG_KEY_PRIVATE;
            break;

        case 1:
            flag = BIP32_FLAG_KEY_PUBLIC;
            break;

        default:
            flag = BIP32_FLAG_KEY_PRIVATE;
            break;
        }
    }

    ext_key derived_key_root;
    ext_key child_key_root;

    res = bip32_key_from_seed(seed, BIP32_ENTROPY_LEN_512, version, 0, &derived_key_root);

    res = bip32_key_from_parent_path(&derived_key_root, childPath.data(), childPath.size(), BIP32_FLAG_KEY_PRIVATE,
                                     &child_key_root);

    uint8_t bytes_out[BIP32_SERIALIZED_LEN];
    res = bip32_key_serialize(&child_key_root, flag, bytes_out, BIP32_SERIALIZED_LEN);

    String hexStr;
    hexStr = toHex(bytes_out, BIP32_SERIALIZED_LEN);
    resp_msg.add(hexStr.c_str());

    sendOSCMessage(resp_msg);
}

/**
 * Unserialize an serialized, extended key.
 *
 * @param String(0) given serialized, extended key as string
 * @param String(1) empty string for future use
 * @return Unserialized key
 */
void routeBip32KeyUnserialize(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeyUnserialize");

    uint8_t serialized_key[BIP32_SERIALIZED_LEN];

    if (msg.isString(0))
    {
        // Get Serialized Key as string
        size_t len = msg.getDataLength(0);
        char char_serialized_key[len];
        msg.getString(0, char_serialized_key, len);

        memcpy(serialized_key,
               fromhex(char_serialized_key),
               BIP32_SERIALIZED_LEN);

        ext_key unserialized_key_root;
        bip32_key_unserialize(serialized_key, BIP32_SERIALIZED_LEN, &unserialized_key_root);

        String hexStrPriv;
        hexStrPriv = toHex(unserialized_key_root.priv_key, 33);
        resp_msg.add(hexStrPriv.c_str());

        String hexStrPub;
        hexStrPub = toHex(unserialized_key_root.pub_key, 33);
        resp_msg.add(hexStrPub.c_str());

        // bip32_key_free(unserialized_key_root);
    }

    sendOSCMessage(resp_msg);
}

/**
 * Converts a private extended key to a public extended key. Afterwards, only public child extended
 * keys can be derived, and only the public serialization can be created.
 * If the provided key is already public, nothing will be done.
 *
 * @param String(0) The extended key.
 * @return   The converted extended key.
 */
void routeBip32KeyStripPriateKey(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeyStripPriateKey");

    if (msg.isString(0))
    {
        // Get Key
        size_t len = msg.getDataLength(0);
        char key[len];
        msg.getString(0, key, len);

        ext_key innerKey;
        memcpy(&innerKey, (char *)fromhex(key), sizeof(ext_key));
        bip32_key_strip_private_key(&innerKey);

        String hexStr;
        hexStr = toHex((uint8_t *)&innerKey, sizeof(ext_key));
        resp_msg.add(hexStr.c_str());
    }
    else
        resp_msg.add("ERROR! Couldnt get key");

    sendOSCMessage(resp_msg);
}

/**
 * Get fingerprint for Bip-32 encoded key.
 *
 * @param String(0) given key as base seed
 * @param String(1) intended derivation path
 * @param int(2) <optional> network version type. default is BIP32_VER_MAIN_PRIVATE
 * @param int(3) <optional> key type. default is BIP32_FLAG_KEY_PRIVATE
 * @param String(4) empty string for future use
 * @return serialized key
 */
void routeBip32KeyGetFingerprint(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeyGetFingerprint");

    char *xprv = NULL;
    char *xpub = NULL;
    uint8_t seed[BIP39_SEED_LEN_512];

    int version = BIP32_VER_MAIN_PRIVATE;
    int flag = BIP32_FLAG_KEY_PRIVATE;

    // Get seed
    if (msg.isString(0)) // logical 'AND' for msg.isString(0) and msg.isString(1)
    {
        int lengthSeed = msg.getDataLength(0);
        char hexStrSeed[lengthSeed];
        msg.getString(0, hexStrSeed, lengthSeed);
        if (lengthSeed != 0)
        {
            memcpy(seed,
                   fromhex(hexStrSeed),
                   BIP39_SEED_LEN_512);
        }
        else
        {
            valise.begin("vault", false);
            String valise_seed = valise.getString("valise_seed", "");
            valise.end();

            memcpy(
                seed,
                fromhex((const char *)valise_seed.c_str()),
                64);
        }
    }

    // Get Path
    std::vector<uint32_t> childPath;
    if (msg.isString(1))
    {
        len = msg.getDataLength(1);
        char pathString[len];
        msg.getString(1, pathString, len);
        childPath = getPath(pathString);
    }

    // Get network version number
    if (msg.isInt(3))
    {
        switch (msg.getInt(3))
        {
        case 0:
            version = BIP32_VER_MAIN_PRIVATE;
            break;

        case 1:
            version = BIP32_VER_TEST_PRIVATE;
            break;

        default:
            version = BIP32_VER_MAIN_PRIVATE;
            break;
        }
    }

    // Get key type flag
    if (msg.isInt(4))
    {
        switch (msg.getInt(4))
        {
        case 0:
            flag = BIP32_FLAG_KEY_PRIVATE;
            break;

        case 1:
            flag = BIP32_FLAG_KEY_PUBLIC;
            break;

        default:
            flag = BIP32_FLAG_KEY_PRIVATE;
            break;
        }
    }

    ext_key derived_key_root;
    ext_key child_key_root;

    res = bip32_key_from_seed(seed, BIP32_ENTROPY_LEN_512, version, 0, &derived_key_root);

    res = bip32_key_from_parent_path(&derived_key_root, childPath.data(), childPath.size(), BIP32_FLAG_KEY_PRIVATE,
                                     &child_key_root);

    uint8_t bytes_out[BIP32_SERIALIZED_LEN];
    res = bip32_key_get_fingerprint(&child_key_root, bytes_out, FINGERPRINT_LEN);

    String hexStrFingerprint;
    hexStrFingerprint = toHex(bytes_out, FINGERPRINT_LEN);
    resp_msg.add(hexStrFingerprint.c_str());

    sendOSCMessage(resp_msg);
}

/**
 * Create a new symmetric key from a base seed or entropy.
 * This creates a new symmetric master or base seed.
 *
 * @param String(0) Give key base seed to use.
 * @return  The resulting symmetric master or base seed.
 */
void routeWallySymKeyFromSeed(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/wallySymKeyFromSeed");

    uint8_t seed[BIP32_ENTROPY_LEN_512];

    if (msg.isString(0))
    {
        // Get Key
        size_t len = msg.getDataLength(0);
        char char_seed[len];
        msg.getString(0, char_seed, len);

        memcpy(seed,
               fromhex(char_seed),
               BIP32_ENTROPY_LEN_512);

        uint8_t symmetric_key[HMAC_SHA512_LEN];
        wally_symmetric_key_from_seed(seed, BIP32_ENTROPY_LEN_512, symmetric_key, HMAC_SHA512_LEN);

        String hexStrSymKey;
        hexStrSymKey = toHex(symmetric_key, HMAC_SHA512_LEN);
        resp_msg.add(hexStrSymKey.c_str());
    }

    sendOSCMessage(resp_msg);
}

/**
 * Create a new symmetric key from parent symmetric key or entropy.
 * This creates a new symmetric master or base key.
 *
 * @param String(0) Entropy to use.
 * @param int(1) Version byte to prepend label. Has to be 0
 * @param String(2) Label, a string according to SLIP-21
 * @param String(3) empty string for future use
 * @return  The resulting key.
 */
void routeWallySymKeyFromParent(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/wallySymKeyFromParent");

    uint8_t parent_sym_key[HMAC_SHA512_LEN];

    uint8_t version = 0x00; // has to be zero by default

    uint8_t child_sym_key[HMAC_SHA512_LEN];

    // Get parent symmetric key
    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        char char_parent_sym_key[length];
        msg.getString(0, char_parent_sym_key, length);
        memcpy(parent_sym_key,
               fromhex(char_parent_sym_key),
               HMAC_SHA512_LEN);
    }

    if (msg.isString(2))
    {
        len = msg.getDataLength(2);
        char char_label[len];
        msg.getString(2, char_label, len);

        wally_symmetric_key_from_parent(parent_sym_key, HMAC_SHA512_LEN,
                                        version,
                                        //(const unsigned char*)char_label.c_str(), len,
                                        reinterpret_cast<unsigned char *>(char_label), len,
                                        child_sym_key, HMAC_SHA512_LEN);

        String hexStrSymKey;
        hexStrSymKey = toHex(child_sym_key, HMAC_SHA512_LEN);
        resp_msg.add(hexStrSymKey.c_str());
    }

    sendOSCMessage(resp_msg);
}

/**
 * Convert a base58 encoded extended key to an extended key
 *
 * @param String(0) The extended key in base58.
 * @return Generated extended key. Private or public key raw. Sending over OSC as string
 */
void routeBip32KeyFromBase58(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32KeyFromBase58");

    ext_key decoded_key_root;

    // Get base58 encoded key
    if (msg.isString(0)) // logical 'AND' for msg.isString(0) and msg.isString(1)
    {
        int lengthBase58 = msg.getDataLength(0);
        char hexStrBase58[lengthBase58];
        msg.getString(0, hexStrBase58, lengthBase58);
        if (lengthBase58 != 0)
        {
            bip32_key_from_base58(hexStrBase58, &decoded_key_root);
        }
    }

    String hexStrPriv;
    hexStrPriv = toHex(decoded_key_root.priv_key, 33);
    resp_msg.add(hexStrPriv.c_str());

    String hexStrPub;
    hexStrPub = toHex(decoded_key_root.pub_key, 33);
    resp_msg.add(hexStrPub.c_str());

    sendOSCMessage(resp_msg);
}

void routeSlip21KeyFromSeed(OSCMessage &msg, int addressOffset)
{
    boolean b;
}

/**
 * Create new extended key from given parameters
 *
 * @return  The extended key
 */
void routeBip32KeyInit(OSCMessage &msg, int addressOffset)
{
    int res;
    size_t len;
    OSCMessage resp_msg("/bip32_key_init");
    uint32_t version = 0;
    uint32_t depth = 0;
    uint32_t child_num = 0;
    uint8_t *temp_ptr = nullptr;
    std::vector<uint8_t> chainCode;
    std::vector<uint8_t> pubKey;
    std::vector<uint8_t> privKey;
    std::vector<uint8_t> hash160;
    std::vector<uint8_t> parent160;
    ext_key *output = nullptr;
    String hexStr;

    if (msg.isInt(0))
        version = msg.getInt(0);
    else
    {
        resp_msg.add("ERROR! Version Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isInt(1))
        depth = msg.getInt(1);
    else
    {
        resp_msg.add("ERROR! Depth Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isInt(2))
        child_num = msg.getInt(2);
    else
    {
        resp_msg.add("ERROR! Child num Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isString(3))
    {
        len = msg.getDataLength(3);
        msg.getString(3, tempBuff, len);

        temp_ptr = (uint8_t *)fromhex(tempBuff);
        chainCode.assign(temp_ptr, temp_ptr + len / 2);
    }
    else
    {
        resp_msg.add("ERROR! Chain code Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isString(4))
    {
        len = msg.getDataLength(4);
        msg.getString(4, tempBuff, len);

        temp_ptr = (uint8_t *)fromhex(tempBuff);
        pubKey.assign(temp_ptr, temp_ptr + len / 2);
    }
    else
    {
        resp_msg.add("ERROR! Pub key Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isString(5))
    {
        len = msg.getDataLength(5);
        msg.getString(5, tempBuff, len);

        temp_ptr = (uint8_t *)fromhex(tempBuff);
        privKey.assign(temp_ptr, temp_ptr + len / 2);
    }
    else
    {
        resp_msg.add("ERROR! Priv key Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isString(6))
    {
        len = msg.getDataLength(6);
        msg.getString(6, tempBuff, len);

        temp_ptr = (uint8_t *)fromhex(tempBuff);
        hash160.assign(temp_ptr, temp_ptr + len / 2);
    }
    else
    {
        resp_msg.add("ERROR! hash160 Wrong Parameter");
        goto SEND_RESPONSE;
    }

    if (msg.isString(7))
    {
        len = msg.getDataLength(7);
        msg.getString(7, tempBuff, len);

        temp_ptr = (uint8_t *)fromhex(tempBuff);
        parent160.assign(temp_ptr, temp_ptr + len / 2);
    }
    else
    {
        resp_msg.add("ERROR! parent160 Wrong Parameter");
        goto SEND_RESPONSE;
    }

    bip32_key_init_alloc(version, depth, child_num,
                         chainCode.data(), chainCode.size(),
                         pubKey.data(), pubKey.size(),
                         privKey.data(), privKey.size(),
                         hash160.data(), hash160.size(),
                         parent160.data(), parent160.size(),
                         &output);

    hexStr = toHex((uint8_t *)output, sizeof(ext_key));
    resp_msg.add(hexStr.c_str());

    bip32_key_free(output);

SEND_RESPONSE:
    sendOSCMessage(resp_msg);
}

/**
 * Create new extended key from given parameters
 *
 * @return  The extended key
 */
void routeEcdsaPubKey(OSCMessage &msg, int addressOffset)
{
    int res;
    bool secret_ok = false;
    size_t len; // to store serialization lengths

    secp256k1_context *ctx = NULL;

    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    uint8_t priv_key[32];
    char char_priv_key[65]; // has to be inside the msg.isString() check ...

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, char_priv_key, length);
    }

    memcpy(priv_key,
           fromhex(char_priv_key),
           32);

    secret_ok = secp256k1_ec_seckey_verify(ctx, priv_key);

    // Derive child key from parent key
    secp256k1_pubkey pubkey;
    bool create_pubkey = false;
    create_pubkey = secp256k1_ec_pubkey_create(ctx, &pubkey, priv_key);

    // serialize the pubkey in compressed format
    uint8_t pub[33];
    len = sizeof(pub);
    secp256k1_ec_pubkey_serialize(ctx, pub, &len, &pubkey, SECP256K1_EC_COMPRESSED);

    String pub_key_hex_str;
    pub_key_hex_str = toHex(pub, 33);

    // Send the result back
    OSCMessage resp_msg("/IHW/ecdsaPubKey");
    resp_msg.add(pub_key_hex_str.c_str());
    resp_msg.add(char_priv_key);
    resp_msg.add((int32_t)len);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(char_priv_key);
}

/** routeEcdsaSigFromBytes
 * 0: priv key
 * 1: hash
 * 2: sig
 */
void routeEcdsaSigFromBytes(OSCMessage
                           &msg,
                       int addressOffset)
{
    int res;

    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /* Private keys created on the trust anchor are starting with 0x00 as prefix*/
    /* Therefore the leading HEX 0x00 has to be dropped before signing          */
    /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    size_t len;
    secp256k1_context *ctx = NULL;

    uint8_t priv_key[32];

    char char_priv_key[65]; // has to be inside the msg.isString() check ...

    uint8_t hash_key[32];
    char char_hash_key[65]; // has to be inside the msg.isString() check ...

    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        msg.getString(0, char_priv_key, length);
    }
    if (msg.isString(2))
    {
        int length = msg.getDataLength(2);
        msg.getString(2, char_hash_key, length);
    }

    memcpy(priv_key,
           fromhex((const char *)char_priv_key),
           32);
    memcpy(hash_key,
           fromhex((const char *)char_hash_key),
           32);
    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    secp256k1_ecdsa_signature sig;

    res = secp256k1_ecdsa_sign(ctx, &sig, hash_key, priv_key, NULL, NULL);

    uint8_t compact[64];
    len = sizeof(compact);
    res = secp256k1_ecdsa_signature_serialize_compact(ctx, compact, &sig);

    bool sig_verify_ok = false;
    secp256k1_ecdsa_signature sig_secp;
    sig_verify_ok = secp256k1_ecdsa_signature_parse_compact(ctx, &sig_secp, compact);

    String sig_hex_str;
    sig_hex_str = toHex(compact, 64);

    OSCMessage resp_msg("/IHW/ecdsaSigFromBytes");
    resp_msg.add(sig_hex_str
                     .

                 c_str()

    );
    resp_msg.add(sig
                     .data);
    resp_msg.add(sig_verify_ok);
    resp_msg.add(char_priv_key);
    resp_msg.add(char_hash_key);

    SLIPSerial.

        beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.

        endPacket();

    resp_msg.

        empty();

    wally_free_string(char_priv_key);
    wally_free_string(char_hash_key);
}

/** routeEcdsaSigVerifyPubkeyHash
 *  Verify a signature against a public key and a hash
 *  @param msg OSCMessage
 *  @param addressOffset int
 */
void routeEcdsaSigVerifyPubkeyHash(OSCMessage &msg, int
                                                        addressOffset)
{
    int res;

    char str_pub_key[67];
    char str_hash[65];

    int len;
    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        len = length;
        msg.getString(0, (char *)str_pub_key, length);
    };
    memcpy(pub_key_buffer,
           fromhex(str_pub_key),
           33);

    if (msg.isString(2))
    {
        int length = msg.getDataLength(2);
        msg.getString(2, (char *)str_hash, length);
    };
    memcpy(hash_buffer,
           fromhex(str_hash),
           32);

    OSCMessage resp_msg("/IHW/ecdsaSigVerifyPubkeyHash");
    resp_msg.add("PubKey and Hash stored");
    resp_msg.add((int32_t)
                     len);
    SLIPSerial.

        beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.

        endPacket();

    resp_msg.

        empty();
}

/* Verify a ECDSA signature */
void routeEcdsaSigVerify(OSCMessage &msg, int addressOffset)
{
    int res;

    uint8_t sig[64];
    char str_sig[129];

    int len;
    if (msg.isString(0))
    {
        int length = msg.getDataLength(0);
        len = length;
        msg.getString(0, (char *)str_sig, length);
    }

    memcpy(sig,
           fromhex(str_sig),
           64);

    secp256k1_pubkey pub;
    secp256k1_ecdsa_signature sig_secp;
    secp256k1_context *ctx = NULL;
    size_t context_size = secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);
    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    bool ok;
    bool check_ok = true;
    bool ctx_ok = true;
    bool parse_ok = true;
    bool parse_compact_ok = true;
    bool verify_ok = true;

    int pub_key_len = 33;
    int hash_len = 32;
    int sig_len = 64;
    uint32_t flags = EC_FLAG_ECDSA;

    if (!pub_key_buffer || pub_key_len != EC_PUBLIC_KEY_LEN ||
        !hash_buffer || hash_len != EC_MESSAGE_HASH_LEN ||
        !is_valid_ec_type(flags) || flags & ~EC_FLAGS_TYPES ||
        !sig || sig_len != EC_SIGNATURE_LEN)
    {
        check_ok = false;
    }

    if (!ctx)
    {
        ctx_ok = false;
    }

    ok = secp256k1_ec_pubkey_parse(ctx, &pub, pub_key_buffer, pub_key_len);
    if (!ok)
    {
        parse_ok = false;
    }

    ok = secp256k1_ecdsa_signature_parse_compact(ctx, &sig_secp, sig);
    if (!ok)
    {
        parse_compact_ok = false;
    }

    ok = secp256k1_ecdsa_verify(ctx, &sig_secp, hash_buffer, &pub);
    if (!ok)
    {
        verify_ok = false;
    }

    String hexStr;
    hexStr = toHex(sig, 64);
    String hexStr2;
    hexStr2 = toHex(pub_key_buffer, 33);
    String hexStr3;
    hexStr3 = toHex(hash_buffer, 32);

    OSCMessage resp_msg("/IHW/ecdsaSigVerify");
    // resp_msg.add((int32_t)res);
    resp_msg.add((int32_t)pub_key_len);
    resp_msg.add(check_ok);
    resp_msg.add(ctx_ok);
    resp_msg.add(parse_ok);
    resp_msg.add(parse_compact_ok);
    resp_msg.add(verify_ok);
    resp_msg.add(ok);
    resp_msg.add(hexStr3.c_str());
    resp_msg.add(hexStr2.c_str());
    resp_msg.add(hexStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void loop()
{
    OSCMessage msg;
    int size;
    // receive a bundle
    while (!SLIPSerial.endofPacket())
        if ((size = SLIPSerial.available()) > 0)
        {
            while (size--)
                msg.fill(SLIPSerial.read());
        }

    if (!msg.hasError())
    {
        /* Core functions */
        msg.route("/IHW/wallyInit", routeWallyInit);
        msg.route("/IHW/wallyCleanup", routeWallyCleanup);
        msg.route("/IHW/wallyGetSecpContext", routeWallyGetSecpContext);
        msg.route("/IHW/wallyGetNewSecpContext", routeWallyGetNewSecpContext);
        msg.route("/IHW/wallySecpContextFree", routeWallySecpContextFree);
        msg.route("/IHW/wallyBZero", routeWallyBZero);
        msg.route("/IHW/wallyFreeString", routeWallyFreeString);
        msg.route("/IHW/wallySecpRandomize", routeWallySecpRandomize);

        /* Crypto functions */

        // check for inconsistency in libwally-core versions of code base
        // msg.route("/IHW/wallyEcSigFromBytesLen", routeWallyEcSigFromBytesLen);
        msg.route("/IHW/wallyEcSigFromBytes", routeWallyEcSigFromBytes);
        msg.route("/IHW/wallyEcSigNormalize", routeWallyEcSigNormalize);
        msg.route("/IHW/wallyEcSigToDer", routeWallyEcSigToDer);
        msg.route("/IHW/wallyEcSigFromDer", routeWallyEcSigFromDer);
        msg.route("/IHW/wallyEcSigVerify2", routeWallyEcSigVerify2);
        msg.route("/IHW/wallyEcSigToPublicKey", routeWallyEcSigToPublicKey);
        msg.route("/IHW/wallyFormatBitcoinMessage", routeWallyFormatBitcoinMessage);
        msg.route("/IHW/wallyEcdh", routeWallyEcdh);

        // only available starting from version release_0.8.8
        // msg.route("/IHW/wallyS2cSigFromBytes", routeWallyS2cSigFromBytes);
        // msg.route("/IHW/wallyS2cCommitmentVerify", routeWallyS2cCommitmentVerify);

        /* Valise functions */
        msg.route("/IHW/valiseMnemonicSeedInit", routeValiseMnemonicSeedInit);
        msg.route("/IHW/valiseMnemonicSet", routeValiseMnemonicSet);
        msg.route("/IHW/valiseMnemonicGet", routeValiseMnemonicGet);
        msg.route("/IHW/valiseSeedSet", routeValiseSeedSet);
        msg.route("/IHW/valiseSeedGet", routeValiseSeedGet);
        msg.route("/IHW/valiseSign", routeValiseSign);

        /* Bip39 functions*/
        msg.route("/IHW/bip39GetLanguages", routeBip39GetLanguages);
        msg.route("/IHW/bip39GetWordlist", routeBip39GetWordlist);
        msg.route("/IHW/bip39GetWord", routeBip39GetWord);
        msg.route("/IHW/bip39Mnemonic", routeBip39Mnemonic);
        msg.route("/IHW/bip39MnemonicFromBytes", routeBip39MnemonicFromBytes);
        msg.route("/IHW/bip39MnemonicToBytes", routeBip39MnemonicToBytes);
        msg.route("/IHW/bip39MnemonicValidate", routeBip39MnemonicValidate);
        msg.route("/IHW/bip39MnemonicToSeed", routeBip39MnemonicToSeed);
        msg.route("/IHW/bip39MnemonicToSeed512", routeBip39MnemonicToSeed512);
        msg.route("/IHW/bip39MnemonicToPrivateKey", routeBip39MnemonicToPrivateKey);
        msg.route("/IHW/bip39NumberBouncer", routeBip39NumberBouncer);
        msg.route("/IHW/bip39MnemonicValidate", routeBip39MnemonicValidate);

        /* Bip32 functions*/
        msg.route("/IHW/bip32_key_init", routeBip32KeyInit);
        msg.route("/IHW/bip32_key_from_seed", routeBip32KeyFromSeed);
        msg.route("/IHW/bip32_key_from_parent", routeBip32KeyFromParent);
        msg.route("/IHW/bip32_key_from_parent2", routeBip32KeyFromParent2);
        // msg.route("/IHW/bip32_key_from_parent_path", routeBip32KeyFromParentPath);
        msg.route("/IHW/bip32_key_from_parent_path_string", routeBip32KeyFromParentPathString);
        msg.route("/IHW/bip32_key_to_base58", routeBip32KeyToBase58);
        msg.route("/IHW/bip32_key_from_base58", routeBip32KeyFromBase58);
        msg.route("/IHW/bip32_key_serialize", routeBip32KeySerialize);
        msg.route("/IHW/bip32_key_unserialize", routeBip32KeyUnserialize);
        msg.route("/IHW/bip32_key_strip_private_key", routeBip32KeyStripPriateKey);
        msg.route("/IHW/bip32_key_get_fingerprint", routeBip32KeyGetFingerprint);

        /* ecdsa functions */
        msg.route("/IHW/ecdsaPubKey", routeEcdsaPubKey);
        msg.route("/IHW/ecdsaSigFromBytes", routeEcdsaSigFromBytes);
        msg.route("/IHW/ecdsaSigVerifyPubkeyHash", routeEcdsaSigVerifyPubkeyHash);
        msg.route("/IHW/ecdsaSigVerify", routeEcdsaSigVerify);

        /* Only available in most recent version 0.8.8 */
        msg.route("/IHW/wallySymKeyFromSeed", routeWallySymKeyFromSeed);
        msg.route("/IHW/wallySymKeyFromParent", routeWallySymKeyFromParent);

        msg.route("/IHW/slip21_key_from_seed", routeSlip21KeyFromSeed);
        msg.route("/IHW/trnd", routeTrnd);
        // msg.route("/IHW/valiseCbor", routeValiseCborEcho);
    }

    /*if(!msg.hasError())
    {
        static int32_t sequencenumber=0;
        // we can sneak an addition onto the end of the bundle
        msg.add("/sequencenumber").add(sequencenumber++);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
            msg.send(SLIPSerial);
        SLIPSerial.endPacket();
    }*/

    delay(20);
}
