#include <Arduino.h>

#include <Wire.h>
#include <HWCDC.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include <Preferences.h>

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"

#include "secp256k1.h"
#include "secp256k1_preallocated.h"


// #include "sdkconfig.h" // generated by "make menuconfig"

#include "mbedtls/esp_config.h"

#define SDA2_PIN GPIO_NUM_18
#define SCL2_PIN GPIO_NUM_19

#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1


/* void i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA2_PIN,
		.scl_io_num = SCL2_PIN,
		.sda_pullup_en = GPIO_PULLUP_DISABLE,
		.scl_pullup_en = GPIO_PULLUP_DISABLE,
		//.master.clk_speed = 100000,
		};
			
	i2c_param_config(I2C_NUM_0 , &i2c_config);
	i2c_driver_install(I2C_NUM_0 , I2C_MODE_MASTER, 0, 0, 0);
}
*/

#include <assert.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <string.h>
#include "esp_system.h"
#include "nvs_flash.h"
#include "nvs.h"

#include <OSCBundle.h>
#include <OSCBoards.h>
#include <SLIPEncodedSerial.h>

//SLIPEncodedSerial SLIPSerial(Serial);  for regular ESP32
//HardwareSerial MySerial(0);
//SLIPEncodedSerial SLIPSerial(Serial); // for XIAO ESP32C3

#include "secp256k1.h"
#include "wally_core.h"
#include "wally_crypto.h"
#include "wally_bip32.h"
#include "wally_bip39.h"
#include "wally_address.h"


#include "wally_script.h"
#include "wally_psbt.h"

extern "C" {
#include "ccan/base64/base64.h"
}

// Endianess
#define SPI_SHIFT_DATA(data, len) __builtin_bswap32((uint32_t)data<<(32-len))
#define SPI_REARRANGE_DATA(data, len) (__builtin_bswap32(data)>>(32-len))

#define EC_FLAGS_TYPES (EC_FLAG_ECDSA | EC_FLAG_SCHNORR)

static bool is_valid_ec_type(uint32_t flags)
{
    return ((flags & EC_FLAGS_TYPES) == EC_FLAG_ECDSA) ||
           ((flags & EC_FLAGS_TYPES) == EC_FLAG_SCHNORR);
}

uint8_t pub_key_buffer[33];
uint8_t hash_buffer[32];

// forward declaration
void err(const char *message, void *data = NULL);

// root HD key
ext_key root;

#define FROMHEX_MAXLEN 512

void memzero(void *const pnt, const size_t len) {
/*#ifdef _WIN32
  SecureZeroMemory(pnt, len);
#elif defined(HAVE_MEMSET_S)
  memset_s(pnt, (rsize_t)len, 0, (rsize_t)len);
#elif defined(HAVE_EXPLICIT_BZERO)
  explicit_bzero(pnt, len);
#elif defined(HAVE_EXPLICIT_MEMSET)
  explicit_memset(pnt, 0, len);
#else*/
    volatile unsigned char *volatile pnt_ = (volatile unsigned char *volatile) pnt;
    size_t i = (size_t) 0U;

    while (i < len) {
        pnt_[i++] = 0U;
    }
// #endif
}

const uint8_t *fromhex(const char *str) {
    static uint8_t buf[FROMHEX_MAXLEN];
    int len = strlen(str) / 2;
    if (len > FROMHEX_MAXLEN) len = FROMHEX_MAXLEN;
    for (int i = 0; i < len; i++) {
        uint8_t c = 0;
        if (str[i * 2] >= '0' && str[i * 2] <= '9') c += (str[i * 2] - '0') << 4;
        if ((str[i * 2] & ~0x20) >= 'A' && (str[i * 2] & ~0x20) <= 'F')
            c += (10 + (str[i * 2] & ~0x20) - 'A') << 4;
        if (str[i * 2 + 1] >= '0' && str[i * 2 + 1] <= '9')
            c += (str[i * 2 + 1] - '0');
        if ((str[i * 2 + 1] & ~0x20) >= 'A' && (str[i * 2 + 1] & ~0x20) <= 'F')
            c += (10 + (str[i * 2 + 1] & ~0x20) - 'A');
        buf[i] = c;
    }
    return buf;
}

void tohexprint(char *hexbuf, uint8_t *str, int strlen) {
    // char hexbuf[strlen];
    for (int i = 0; i < strlen / 2; i++) {
        sprintf(&hexbuf[2 * i], "%02X", str[i]);
    }
    hexbuf[strlen - 2] = '\0';
}

size_t toHex(const uint8_t *array, size_t arraySize, char *output, size_t outputSize) {
    if (array == NULL || output == NULL) { return 0; }
    // uint8_t * array = (uint8_t *) arr;
    if (outputSize < 2 * arraySize) {
        return 0;
    }
    memzero(output, outputSize);

    for (size_t i = 0; i < arraySize; i++) {
        output[2 * i] = (array[i] >> 4) + '0';
        if (output[2 * i] > '9') {
            output[2 * i] += 'a' - '9' - 1;
        }

        output[2 * i + 1] = (array[i] & 0x0F) + '0';
        if (output[2 * i + 1] > '9') {
            output[2 * i + 1] += 'a' - '9' - 1;
        }
    }
    return 2 * arraySize;
}

String toHex(const uint8_t *array, size_t arraySize) {
    if (array == NULL) { return String(); }
    size_t outputSize = arraySize * 2 + 1;
    char *output = (char *) malloc(outputSize);
    if (output == NULL) { return String(); }

    toHex(array, arraySize, output, outputSize);

    String result(output);

    memzero(output, outputSize);
    free(output);

    return result;
}

//HardwareSerial Serial0(0);
HWCDC SerialESP;
SLIPEncodedSerial SLIPSerial(SerialESP); // for XIAO ESP32C3  
//SLIPEncodedSerial SLIPSerial(Serial); // for AI Thinker ESP-C3-32S

Preferences valise;    // ESP32-C3 to use NVS


void setup() {
    //begin communication via IÂ²C
    //Wire.setPins(SDA_PIN, SCL_PIN);
    //Wire.begin(SDA_PIN, SCL_PIN);

    SLIPSerial.begin(115200);
    //Serial.begin(115200);

}

void routeValiseInit(OSCMessage &msg, int addressOffset) {
    boolean res;

    valise.begin("vault", false);

    const char *mnemonic = "wife balcony tortoise among impact arch conduct bronze vehicle story menu next brisk rigid mimic scissors monitor worth talk vanish cereal fence excess danger";
    valise.putString("valise_mnemonic", mnemonic);

    valise.end();

    OSCMessage resp_msg("/valiseInit");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeValiseGet(OSCMessage &msg, int addressOffset) {
    valise.begin("vault", false);

    String valise_mnemonic = valise.getString("valise_mnemonic", "");

    valise.end();

    OSCMessage resp_msg("/valiseGet");
    resp_msg.add(valise_mnemonic.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeValiseSign(OSCMessage &msg, int addressOffset)
{
  secp256k1_context *ctx = NULL;

  int res;    // to store results of function calls
  size_t len; // to store serialization lengths

  // first we need to create the context
  // this is the size of memory to be allocated
  size_t context_size = secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

  ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

  // secret as hex string
  // bdb51a16eb6460ec16f84d7b6f19e20d9b9ab558fa0e9ae4bb493ef779f14055
  // import into python ecdsa code
  //
  // sk = ecdsa.SigningKey.from_string(binascii.unhexlify("bdb51a16eb6460ec16f84d7b6f19e20d9b9ab558fa0e9ae4bb493ef779f14055") ,curve=ecdsa.SECP256k1, hashfunc=hashlib.sha256)
  // private_key = sk.to_string()
  //
  // msg = hashlib.sha256(b"hello").digest().hex()
  // >>> '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'
  // 
  // public_key = vk.to_string('compressed').hex()
  // >>> '02822d18bd250a11e5c86d90a801bf42443c8dca93cb62724da660b849d2514277'
  //
  //  msg = hashlib.sha256(b"hello").digest()
  // signature = sk.sign(msg,hashfunc=hashlib.sha256)
  // signature.hex()

  // some random secret key
  uint8_t secret[] = {
    0xbd, 0xb5, 0x1a, 0x16, 0xeb, 0x64, 0x60, 0xec, 
    0x16, 0xf8, 0x4d, 0x7b, 0x6f, 0x19, 0xe2, 0x0d, 
    0x9b, 0x9a, 0xb5, 0x58, 0xfa, 0x0e, 0x9a, 0xe4, 
    0xbb, 0x49, 0x3e, 0xf7, 0x79, 0xf1, 0x40, 0x55
  };

  // Makes sense to check if secret key is valid.
  // It will be ok in most cases, only if secret > N it will be invalid
  res = secp256k1_ec_seckey_verify(ctx, secret);

  // computing corresponding pubkey
  secp256k1_pubkey pubkey;
  res = secp256k1_ec_pubkey_create(ctx, &pubkey, secret);

  // serialize the pubkey in compressed format
  uint8_t pub[33];
  len = sizeof(pub);
  secp256k1_ec_pubkey_serialize(ctx, pub, &len, &pubkey, SECP256K1_EC_COMPRESSED);

  // this is how you parse the pubkey
  res = secp256k1_ec_pubkey_parse(ctx, &pubkey, pub, 33);

  // hash of the string "hello"
  uint8_t hash[32] = { 
    0x2c, 0xf2, 0x4d, 0xba, 0x5f, 0xb0, 0xa3, 0x0e, 
    0x26, 0xe8, 0x3b, 0x2a, 0xc5, 0xb9, 0xe2, 0x9e, 
    0x1b, 0x16, 0x1e, 0x5c, 0x1f, 0xa7, 0x42, 0x5e, 
    0x73, 0x04, 0x33, 0x62, 0x93, 0x8b, 0x98, 0x24 
  };
  // signing
  secp256k1_ecdsa_signature sig;

  res = secp256k1_ecdsa_sign(ctx, &sig, hash, secret, NULL, NULL);

  //uint8_t sig_secp[64];
  //res = secp256k1_ecdsa_signature_parse_compact(ctx, &sig, sig_secp);

  uint8_t der[72];
  len = sizeof(der);
  res = secp256k1_ecdsa_signature_serialize_der(ctx, der, &len, &sig);

  uint8_t compact[64];
  len = sizeof(compact);
  res = secp256k1_ecdsa_signature_serialize_compact(ctx, compact, &sig);

  // signature verification
  Serial.print("=== Signature verification ===\r\n");
  res = secp256k1_ecdsa_verify(ctx, &sig, hash, &pubkey);

  String pubStr;
  pubStr = toHex(pub, 33);

  String compactStr;
  compactStr = toHex(compact, 64);

  String derStr;
  derStr = toHex(der, 72);

  OSCMessage resp_msg("/IHW/valiseSign");
  resp_msg.add((int32_t) res);
  resp_msg.add(pubStr.c_str());
  resp_msg.add(compactStr.c_str());
  resp_msg.add(derStr.c_str());
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

}


void routeWallyInit(OSCMessage &msg, int addressOffset) {
    wally_init(0x00);

    OSCMessage resp_msg("/wallyInit");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}


void routeWallyCleanup(OSCMessage &msg, int addressOffset) {
    wally_cleanup(0x00);

    OSCMessage resp_msg("/wallyCleanup");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyGetSecpContext(OSCMessage &msg, int addressOffset) {
    secp256k1_context_struct *ctxStrct;
    wally_get_secp_context();

    OSCMessage resp_msg("/wallyGetSecpContext");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyGetNewSecpContext(OSCMessage &msg, int addressOffset) {
    secp256k1_context_struct *ctxStrct;
    // wally_get_new_secp_context();

    OSCMessage resp_msg("/wallyGetNewSecpContext");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallySecpContextFree(OSCMessage &msg, int addressOffset) {
    secp256k1_context_struct *ctxStrct;
    //wally_secp_context_free(ctxStrct);

    OSCMessage resp_msg("/wallySecpContextFree");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}


void routeWallyBZero(OSCMessage &msg, int addressOffset) {
    char *bytes;
    size_t len;
    wally_bzero(bytes, len);

    OSCMessage resp_msg("/wallyBZero");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyFreeString(OSCMessage &msg, int addressOffset) {
    char *str;
    wally_free_string(str);

    OSCMessage resp_msg("/wallyBZero");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallySecpRandomize(OSCMessage &msg, int addressOffset) {
    unsigned char *bytes;
    size_t len;
    wally_secp_randomize(bytes, len);

    OSCMessage resp_msg("/wallyBZero");
    resp_msg.add("0");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}


/* ----------------------------------------------------------------*/
/* Crypto functions                                                */
/* ----------------------------------------------------------------*/

/* part of documentation but deprecated */
/* void routeWallyEcSigFromBytesLen(OSCMessage &msg, int addressOffset)
{
  int res;
  //uint8_t priv_key[33] = "7BC81198140916367B5CED9BADA28C37"; 
  uint8_t priv_key[33];
  size_t priv_key_len;
  // uint8_t hash_key[33] = "C99A85979AD295811330C5689C730250";
  uint8_t hash_key[33];
  size_t hash_key_len;
  uint32_t flags;
  size_t* len;

  priv_key_len = 32;
  hash_key_len = 32;
  int length;

  if(msg.isString(0))
  {
      length=msg.getDataLength(0);
      msg.getString(0, (char*)priv_key,length);
  }

  if(msg.isString(2))
  {
      length=msg.getDataLength(2);
      msg.getString(2, (char*)hash_key,length);  
  }


  res = wally_ec_sig_from_bytes_len(
            (uint8_t*)priv_key, 
            priv_key_len, 
            (uint8_t*)hash_key, 
            hash_key_len, 
            EC_FLAG_ECDSA, 
            (unsigned char*)len
        );

  OSCMessage resp_msg("/IHW/wallyEcSigFromBytesLen");
  resp_msg.add(len);

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
} */

void routeWallyEcSigFromBytes(OSCMessage &msg, int addressOffset) {
    int res;
    size_t len;
    secp256k1_context *ctx = NULL;

    uint8_t priv_key[32];

    char char_priv_key[65]; // has to be inside the msg.isString() check ...

  uint8_t hash_key[32];
  char char_hash_key[65]; // has to be inside the msg.isString() check ...

  if(msg.isString(0))
  {
      int length=msg.getDataLength(0);
      msg.getString(0, char_priv_key, length);
  }
  if(msg.isString(2))
  {
      int length=msg.getDataLength(2);
      msg.getString(2, char_hash_key, length); 
  }


  memcpy(priv_key,
         fromhex((const char*)char_priv_key),
         32
  );
  memcpy(hash_key,
         fromhex((const char*)char_hash_key),
         32
  );
    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    secp256k1_ecdsa_signature sig;

    res = secp256k1_ecdsa_sign(ctx, &sig, hash_key, priv_key, NULL, NULL);

    uint8_t compact[64];
    len = sizeof(compact);
    res = secp256k1_ecdsa_signature_serialize_compact(ctx, compact, &sig);

    bool sig_verify_ok = false;
    secp256k1_ecdsa_signature sig_secp;
    sig_verify_ok = secp256k1_ecdsa_signature_parse_compact(ctx, &sig_secp, compact);

    String sig_hex_str;
    sig_hex_str = toHex(compact, 64);


  OSCMessage resp_msg("/IHW/wallyEcSigFromBytes");
  resp_msg.add(sig_hex_str.c_str());
  resp_msg.add(sig.data);
  resp_msg.add(sig_verify_ok);
  resp_msg.add(char_priv_key);
  resp_msg.add(char_hash_key);


  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
  resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket();
  resp_msg.empty();

  wally_free_string(char_priv_key);
  wally_free_string(char_hash_key);

}

void routeWallyEcSigNormalize(OSCMessage &msg, int addressOffset) {
    int res;

    uint8_t sig[64];
    char char_sig[129];

    uint8_t bytes_out[64];


    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        msg.getString(0, char_sig, length);
    }

    memcpy(sig,
           fromhex(char_sig),
           64
    );

    res = wally_ec_sig_normalize(
            sig,
            EC_SIGNATURE_LEN,
            bytes_out,
            EC_SIGNATURE_LEN
    );

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(bytes_out, 64);

    OSCMessage resp_msg("/IHW/wallyEcSigNormalize");
    resp_msg.add(hexStr.c_str());
    // resp_msg.add("test message");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyEcSigToDer(OSCMessage &msg, int addressOffset) {
    int res;

    uint8_t sig[64];

    char str_sig[129];

    uint8_t der[73];

    size_t len;

    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        msg.getString(0, str_sig, length);
    }

    memcpy(sig,
           fromhex(str_sig),
           64
    );

    res = wally_ec_sig_to_der(
            sig,
            EC_SIGNATURE_LEN,
            der,
            EC_SIGNATURE_DER_MAX_LEN,
            &len
    );

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(der, EC_SIGNATURE_DER_MAX_LEN);

    OSCMessage resp_msg("/IHW/wallyEcSigToDer");
    resp_msg.add(hexStr.c_str());
    //resp_msg.add("test message");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyEcSigFromDer(OSCMessage &msg, int addressOffset) {
    int res;

    uint8_t der[72];

    char str_der[145];

    uint8_t sig[64];


    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        msg.getString(0, (char *) str_der, length);
    };
    memcpy(der,
           fromhex(str_der),
           72
    );

    res = wally_ec_sig_from_der(
            der,
            72,
            sig,
            64
    );

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(sig, 64);

    OSCMessage resp_msg("/IHW/wallyEcSigFromDer");
    resp_msg.add(hexStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}

void routeWallyEcSigVerifyPubkeyHash(OSCMessage &msg, int addressOffset)
{
  int res;

  char str_pub_key[67];
  char str_hash[65];

  int len;
  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    len = length;
    msg.getString(0, (char*)str_pub_key, length);
  };
  memcpy(pub_key_buffer, 
        fromhex(str_pub_key),
        33
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_hash, length);
  };
  memcpy(hash_buffer, 
        fromhex(str_hash),
        32
  );

  OSCMessage resp_msg("/IHW/wallyEcSigVerifyPubkeyHash");
  resp_msg.add("PubKey and Hash stored");
  resp_msg.add((int32_t)len);
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();

}

void routeWallyEcSigVerify(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t sig[64];
  char str_sig[129];

  int len;
  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    len = length;
    msg.getString(0, (char*)str_sig, length);
  }

  memcpy(sig, 
        fromhex(str_sig),
        64
  );

  /* res = wally_ec_sig_verify(
            (const unsigned char *)pub_key_buffer, 
            EC_PUBLIC_KEY_LEN, 
            (const unsigned char *)hash_buffer,
            EC_MESSAGE_HASH_LEN,
            EC_FLAG_ECDSA,
            (const unsigned char *)sig, 
            EC_SIGNATURE_LEN 
  ); */

    secp256k1_pubkey pub;
    secp256k1_ecdsa_signature sig_secp;
    secp256k1_context *ctx = NULL;
    size_t context_size = secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);
    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    //const secp256k1_context *ctx = secp_ctx();
    
    bool ok;
    bool check_ok = true;
    bool ctx_ok = true;
    bool parse_ok = true;
    bool parse_compact_ok = true;
    bool verify_ok = true;

    int pub_key_len = 33;
    int hash_len = 32;
    int sig_len = 64;
    uint32_t flags = EC_FLAG_ECDSA;

    

    if (!pub_key_buffer || pub_key_len != EC_PUBLIC_KEY_LEN ||
        !hash_buffer || hash_len != EC_MESSAGE_HASH_LEN  ||
        !is_valid_ec_type(flags) || flags & ~EC_FLAGS_TYPES ||
        !sig || sig_len != EC_SIGNATURE_LEN
        )
        {
        check_ok = false;
        }

    if (!ctx)
    {
        ctx_ok = false;
    }

    ok = secp256k1_ec_pubkey_parse(ctx, &pub, pub_key_buffer, pub_key_len);
    if(!ok)
    {
      parse_ok = false;
    }


    ok = secp256k1_ecdsa_signature_parse_compact(ctx, &sig_secp, sig);
    if(!ok)
    {
      parse_compact_ok = false;
    }

    ok = secp256k1_ecdsa_verify(ctx, &sig_secp, hash_buffer, &pub);
    if(!ok)
    {
      verify_ok = false;
    }


  String hexStr;
  hexStr = toHex(sig, 64);
  String hexStr2;
  hexStr2 = toHex(pub_key_buffer, 33);
  String hexStr3;
  hexStr3 = toHex(hash_buffer, 32);

  OSCMessage resp_msg("/IHW/wallyEcSigVerify");
  //resp_msg.add((int32_t)res);
  resp_msg.add((int32_t)pub_key_len);
  resp_msg.add(check_ok);
  resp_msg.add(ctx_ok);
  resp_msg.add(parse_ok);
  resp_msg.add(parse_compact_ok);
  resp_msg.add(verify_ok);
  resp_msg.add(ok);
  resp_msg.add(hexStr3.c_str());
  resp_msg.add(hexStr2.c_str());
  resp_msg.add(hexStr.c_str());
  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket(); 
  resp_msg.empty();
}

void routeWallyEcSigToPublicKey(OSCMessage &msg, int addressOffset) {
    int res;

    uint8_t pub_key[33];

  uint8_t hash[32];
  char str_hash[65];

    uint8_t sig[64];
    char str_sig[129];

    size_t len;



  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_hash, length);
  };
  memcpy(hash, 
        fromhex(str_hash),
        32
  );

    if (msg.isString(1)) {
        int length = msg.getDataLength(2);
        msg.getString(1, (char *) str_sig, length);
    }
    memcpy(sig,
           fromhex(str_sig),
           64
    );

    res = wally_ec_sig_to_public_key(
            hash,
            32,
            sig,
            64,
            pub_key,
            len
    );

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(pub_key, 33);

    OSCMessage resp_msg("/IHW/wallyEcSigToPublicKey");
    resp_msg.add(hexStr.c_str());
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
}


void routeWallyFormatBitcoinMessage(OSCMessage &msg, int addressOffset) {
    int res;

    uint8_t btc_msg[512];
    char str_btc_msg[1025];

    uint8_t btc_msg_hash[32];

    int *len;
    size_t *written;

    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        msg.getString(0, (char *) str_btc_msg, length);
        len = &length;
    };

    memcpy(btc_msg,
           fromhex(str_btc_msg),
           *len
    );

    res = wally_format_bitcoin_message(
            btc_msg, *len,
            BITCOIN_MESSAGE_FLAG_HASH,
            btc_msg_hash, 32,
            written
    );

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(btc_msg_hash, 32);

    OSCMessage resp_msg("/IHW/wallyFormatBitcoinMessage");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(str_btc_msg);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

}

void routeWallyEcdh(OSCMessage &msg, int addressOffset) {
    int res;

    uint8_t pub_key[33];
    char str_pub_key[66];

    uint8_t priv_key[32];
    char str_priv_key[64];

    uint8_t shared_secret[32];


    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        msg.getString(0, str_pub_key, length);
    };

    memcpy(pub_key,
           fromhex(str_pub_key),
           33
    );

    if (msg.isString(1)) {
        int length = msg.getDataLength(1);
        msg.getString(1, str_priv_key, length);
    };

    memcpy(priv_key,
           fromhex(str_priv_key),
           32
    );


    res = wally_ecdh(
            (const unsigned char *) pub_key, EC_PUBLIC_KEY_LEN,
            (const unsigned char *) priv_key, EC_PRIVATE_KEY_LEN,
            (unsigned char *) shared_secret, SHA256_LEN
    );

    /* Requirement by Arduino to stream strings back to requestor */
    String hexStr;
    hexStr = toHex(shared_secret, 32);

    String hexStrPub;
    hexStrPub = toHex(pub_key, 33);

    String hexStrPriv;
    hexStrPriv = toHex(priv_key, 32);

    OSCMessage resp_msg("/IHW/wallyEcdh");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(hexStrPub.c_str());
    resp_msg.add(hexStrPriv.c_str());

    //resp_msg.add(str_pub_key);
    //resp_msg.add(str_priv_key);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

}

/*void routeWallyS2cSigFromBytes(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t priv_key[32];
  char str_priv_key[66];  // /* EC_PRIVATE_KEY_LEN - 32

  uint8_t msg_hash[32];
  char str_msg_hash[66]; // /* EC_MESSAGE_HASH_LEN - 32

  uint8_t s2c_data[32];
  char str_s2c_data[66]; // /* WALLY_S2C_DATA_LEN - 32

  // /* EC_FLAG_ECDSA

  uint8_t s2c_opening_out[33];
  char str_s2c_opening_out[68]; // /* WALLY_S2C_OPENING_LEN - 32

  uint8_t sig[64]; // /* EC_SIGNATURE_LEN - 64

  int len = 64;

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_priv_key, length);
  };

  memcpy(priv_key,
        fromhex(str_priv_key),
        32
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, (char*)str_msg_hash, length);
  };

  memcpy(msg_hash,
        fromhex(str_msg_hash),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_s2c_data, length);
  };

  memcpy(s2c_data,
        fromhex(str_s2c_data),
        32
  );

  res = wally_s2c_sig_from_bytes(
      priv_key, 32,
      msg_hash, 32,
      s2c_data, 32,
      EC_FLAG_ECDSA,
      s2c_opening_out, 33,
      sig, 64
  )

  // /* Requirement by Arduino to stream strings back to requestor
  String hexStrS2cOpeningOut;
  hexStrS2cOpeningOut = toHex(s2c_opening_out, 33);

  String hexStrSig;
  hexStrSig = toHex(sig, 64);


  OSCMessage resp_msg("/IHW/wallyS2cSigFromBytes");
  resp_msg.add(hexStrS2cOpeningOut.c_str());
  resp_msg.add(hexStrSig.c_str());

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket();
  resp_msg.empty();

} */


/* void routeWallyS2cCommitmentVerify(OSCMessage &msg, int addressOffset)
{
  int res;

  uint8_t sig[64]; // /* EC_SIGNATURE_LEN - 64
  char str_sig[128];

  uint8_t s2c_data[32];
  char str_s2c_data[66]; // /* WALLY_S2C_DATA_LEN - 32

  uint8_t s2c_opening_out[33];
  char str_s2c_opening_out[68]; // /* WALLY_S2C_OPENING_LEN - 32

  // /* EC_FLAG_ECDSA

  if(msg.isString(0))
  {
    int length=msg.getDataLength(0);
    msg.getString(0, (char*)str_sig, length);
  };

  memcpy(sig,
        fromhex(str_sig),
        64
  );

  if(msg.isString(1))
  {
    int length=msg.getDataLength(1);
    msg.getString(1, (char*)str_s2c_data, length);
  };

  memcpy(s2c_data,
        fromhex(str_s2c_data),
        32
  );

  if(msg.isString(2))
  {
    int length=msg.getDataLength(2);
    msg.getString(2, (char*)str_s2c_opening_out, length);
  };

  memcpy(s2c_opening_out,
        fromhex(str_s2c_opening_out),
        33
  );

  res = wally_s2c_commitment_verify(
      sig, 64,
      s2c_data, 32,
      s2c_opening_out, 33,
      EC_FLAG_ECDSA
  )

  OSCMessage resp_msg("/IHW/wallyCommitmentVerify");
  resp_msg.add("True");

  SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
      resp_msg.send(SLIPSerial);
  SLIPSerial.endPacket();
  resp_msg.empty();

} */


/* ----------------------------------------------------------------*/
/* wally bip39 functions                                           */
/* ----------------------------------------------------------------*/

void routeBip39GetLanguages(OSCMessage &msg, int addressOffset) {
    int res;
    char *output = NULL;

    res = bip39_get_languages(&output);

    OSCMessage resp_msg("/bip39GetLanguages");
    resp_msg.add(output);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(output);
}

void routeBip39GetWordlist(OSCMessage &msg, int addressOffset) {
    int res;

    if (msg.isString(0)) {
        struct words *output;
        int length = msg.getDataLength(0);
        char lang[length];
        msg.getString(0, lang, length);

        res = bip39_get_wordlist(lang, &output);

        OSCMessage resp_msg("/bip39GetWordlist");
        resp_msg.add(output);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        resp_msg.empty();
    }
}

void routeBip39GetWord(OSCMessage &msg, int addressOffset) {
    int res;
    struct words *w;

    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        char lang[length];
        msg.getString(0, lang, length);
        res = bip39_get_wordlist(lang, &w);
    }

    if (msg.isInt(1)) {
        // don't forget problem with endianess
        char *output;
        int nth_word = msg.getInt(1);
        res = bip39_get_word(w, nth_word, &output);

        OSCMessage resp_msg("/bip39GetWordlist");

        char str_nth_word[10];
        sprintf(str_nth_word, "%d", nth_word);
        resp_msg.add(str_nth_word);
        resp_msg.add(output);

        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        resp_msg.empty();

        wally_free_string(output);
    }
}

void routeBip39NumberBouncer(OSCMessage &msg, int addressOffset) {
    int res;

    if (msg.isInt(0)) {
        int nth_word = msg.getInt(0);

        OSCMessage resp_msg("/bip39GetNumberBouncer");

        char str_nth_word[10];
        sprintf(str_nth_word, "%d", nth_word);
        resp_msg.add((int32_t) nth_word);

        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        resp_msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        resp_msg.empty();
    }
}

void routeBipMnemonicFromBytes(OSCMessage &msg, int addressOffset) {
    boolean b;
}

void routeBipMnemonicToBytes(OSCMessage &msg, int addressOffset) {
    boolean b;
}

void routeBipMnemonicValidate(OSCMessage &msg, int addressOffset) {
    boolean b;
}

void routeMnemonicToPrivateKey(OSCMessage &msg, int addressOffset) {
    int res;

    char phrase[512];
    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        msg.getString(0, phrase, length);
    }

    // Convert mnemonic to seed
    uint8_t seed[BIP39_SEED_LEN_512];
    size_t seed_len;
    res = bip39_mnemonic_to_seed(phrase, "my password", seed, sizeof(seed), &seed_len);
    // Generate BIP32 master key from seed
    res = bip32_key_from_seed(seed, sizeof(seed), BIP32_VER_MAIN_PRIVATE, 0, &root);

    // // Clear seed from memory for security
    memset(seed, 0, sizeof(seed_len));

    // // // Convert master_key to base58 string
    char *base58_master_key = NULL;
    res = bip32_key_to_base58(&root, BIP32_FLAG_KEY_PRIVATE, &base58_master_key);

    String hexStr;
    hexStr = toHex(root.priv_key, 33);

    // Send the result back
    OSCMessage resp_msg("/IHW/mnemonicToPrivateKey");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(base58_master_key);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(base58_master_key);
    wally_free_string(phrase);
}

void routeBipMnemonicToSeed512(OSCMessage &msg, int addressOffset) {
    boolean b;
}


void routeMnemonic(OSCMessage &msg, int addressOffset) {
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes(NULL, se_rnd, sizeof(se_rnd), &phrase);

    msg.add(phrase);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void routeEntropy(OSCMessage &msg, int addressOffset) {
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    //const char *seed;
    //seed = toHex(se_rnd, 32).c_str();

    char seed[32];

    memset(seed, '\0', sizeof(seed));
    for (int i = 0; i < 31; i++) {
        static char tmp[4] = {};
        sprintf(tmp, "%02X", se_rnd[i]);
        strcpy(seed + i, tmp);
    }

    //msg.add("2573548DF4251F3048ABA137EFEEC11E59C0738D47C88B46462EDE80BEFFA2CA");

    msg.add(seed);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void routeTrnd(OSCMessage &msg, int addressOffset) {
    int len;

    if (msg.isInt(0)) {
        len = msg.getInt(0);
        uint8_t se_rnd[len] = {0};
        esp_fill_random(se_rnd, len);

        char trnd[len];
        memset(trnd, '\0', sizeof(trnd));
        for (int i = 0; i < len - 1; i++) {
            static char tmp[4] = {};
            sprintf(tmp, "%02X", se_rnd[i]);
            strcpy(trnd + i, tmp);
        }

        msg.add(trnd);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
        msg.send(SLIPSerial);
        SLIPSerial.endPacket();
        msg.empty();
    }
}

void routeCborEcho(OSCMessage &msg, int addressOffset) {

    OSCMessage msg2("/cbor/echo");
    int res;
    size_t len;

    uint8_t se_rnd[32] = {0};
    esp_fill_random(se_rnd, 32);

    char *phrase = NULL;
    res = bip39_mnemonic_from_bytes(NULL, se_rnd, sizeof(se_rnd), &phrase);

    msg2.add(
            "d08355a20101055001010101010101010101010101010101a10458246d65726961646f632e6272616e64796275636b406275636b6c616e642e6578616d706c655820c4af85ac4a5134931993ec0a1863a6e8c66ef4c9ac16315ee6fecd9b2e1c79a1");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg2.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void routeMnemonicToBytes(OSCMessage &msg, int addressOffset) {
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];

    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        char phrase[length];
        msg.getString(0, phrase, length);
        //Serial.println(phrase);

        // converting recovery phrase to bytes
        res = bip39_mnemonic_to_bytes(NULL, phrase, bytes_out, sizeof(bytes_out), &len);
    }

    String hexStr;
    hexStr = toHex(bytes_out, 32);
    //Serial.println(hexStr);

    OSCMessage resp_msg("/mnemonicToBytes");
    resp_msg.add(hexStr.c_str());
    //resp_msg.add("hello");
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
    delay(20);
}

void routeMnemonicFromBytes(OSCMessage &msg, int addressOffset) {
    int res;
    size_t len;
    uint8_t bytes_out[BIP39_SEED_LEN_512];
    char *phrase = NULL;

    if (msg.isString(0)) {
        int length = msg.getDataLength(0);
        char hexStr[length];
        msg.getString(0, hexStr, length);
        //Serial.println(hexStr);

        res = bip39_mnemonic_from_bytes(NULL, (const unsigned char *) fromhex(hexStr), 32, &phrase);
    }

    OSCMessage resp_msg("/mnemonicFromBytes");
    resp_msg.add(phrase);
    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();
    delay(20);
}

void routeSecp256k1PubKey(OSCMessage &msg, int addressOffset) {
    int res;
    bool secret_ok = false;
    size_t len; // to store serialization lengths

    secp256k1_context *ctx = NULL;

    ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY | SECP256K1_CONTEXT_SIGN);

    uint8_t priv_key[32];
    char char_priv_key[65]; // has to be inside the msg.isString() check ...

    if(msg.isString(0))
    {
        int length=msg.getDataLength(0);
        msg.getString(0, char_priv_key, length);
    }

    memcpy(priv_key,
           fromhex(char_priv_key),
           32
    );

    secret_ok = secp256k1_ec_seckey_verify(ctx, priv_key);

    // Derive child key from parent key
    secp256k1_pubkey pubkey;
    bool create_pubkey = false;
    create_pubkey = secp256k1_ec_pubkey_create(ctx, &pubkey, priv_key);

    // serialize the pubkey in compressed format
    uint8_t pub[33];
    len = sizeof(pub);
    secp256k1_ec_pubkey_serialize(ctx, pub, &len, &pubkey, SECP256K1_EC_COMPRESSED);

    String pub_key_hex_str;
    pub_key_hex_str = toHex(pub, 33);

    // Send the result back
    OSCMessage resp_msg("/IHW/secp256k1PubKey");
    resp_msg.add(pub_key_hex_str.c_str());
    resp_msg.add(char_priv_key);
    resp_msg.add((int32_t) len);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(char_priv_key);
}

void routeBip32KeyFromParent(OSCMessage &msg, int addressOffset) {
    int res;

  char char_priv_key[65]; // has to be inside the msg.isString() check ...

  if(msg.isString(0))
  {
      int length=msg.getDataLength(0);
      msg.getString(0, char_priv_key, length);
  }

  ext_key parent_key;
  memcpy(parent_key.priv_key,
          fromhex(char_priv_key),
          32
  );

    uint32_t child_index = msg.getInt(2);

    // Derive child key from parent key
    ext_key child_ext_key;
    res = bip32_key_from_parent(&parent_key, child_index, BIP32_FLAG_KEY_PUBLIC, &child_ext_key);
    if (res != WALLY_OK) {
        // Handle the error
        Serial.println("Error: Failed to derive child key from parent key");
        return;
    }

    // Convert child_ext_key to base58 string
    char *base58_child_key = NULL;
    res = bip32_key_to_base58(&child_ext_key, BIP32_FLAG_KEY_PUBLIC, &base58_child_key);
    if (res != WALLY_OK) {
        // Handle the error
        Serial.println("Error: Failed to convert child key to base58");
        return;
    }

    String hexStr;
    hexStr = toHex(child_ext_key.pub_key, 33);

    // Send the result back
    OSCMessage resp_msg("/IHW/bip32KeyFromParent");
    resp_msg.add(hexStr.c_str());
    resp_msg.add(base58_child_key);
    resp_msg.add((int32_t) child_index);

    SLIPSerial.beginPacket();
    resp_msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    resp_msg.empty();

    wally_free_string(base58_child_key);
}

void routeBip32KeyFromSeed(OSCMessage &msg, int addressOffset) {
    int res;
    int res2;
    size_t len;

    if (msg.isString(0)) {
        //res = wally_init(0);

        int length = msg.getDataLength(0);

        char hexStr[length];
        msg.getString(0, hexStr, length);

        /**************** BIP-39 recovery phrase ******************/

        // random buffer should be generated by TRNG or somehow else
        // but we will use predefined one for demo purposes
        // 16 bytes will generate a 12-word recovery phrase
        uint8_t rnd[] = {
                0xAC, 0x91, 0xD3, 0xBC, 0x1B, 0x7C, 0x06, 0x2E,
                0x21, 0xB5, 0x86, 0xA0, 0x2D, 0xBE, 0x5D, 0x24
        };

        // creating a recovery phrase
        char *phrase = NULL;
        res = bip39_mnemonic_from_bytes(NULL, (const unsigned char *) fromhex((const char *) hexStr), 32, &phrase);
        //res = bip39_mnemonic_from_bytes(NULL, rnd, sizeof(rnd), &phrase);


        // converting recovery phrase to seed
        uint8_t seed[BIP39_SEED_LEN_512];
        res2 = bip39_mnemonic_to_seed(phrase, "my password", seed, sizeof(seed), &len);

        // don't forget to securely clean up the string when done
        wally_free_string(phrase);

        res = bip32_key_from_seed(seed, sizeof(seed), BIP32_VER_TEST_PRIVATE, 0, &root);
        //get base58 xprv string
        char *xprv = NULL;
        res = bip32_key_to_base58(&root, BIP32_FLAG_KEY_PRIVATE, &xprv);

        msg.add(xprv);
    }

    SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
    msg.send(SLIPSerial);
    SLIPSerial.endPacket();
    msg.empty();
}

void loop() {
    OSCMessage msg;
    int size;
    //receive a bundle
    while (!SLIPSerial.endofPacket())
        if ((size = SLIPSerial.available()) > 0) {
            while (size--)
                msg.fill(SLIPSerial.read());
        }

    if (!msg.hasError()) {
        /* Core functions */
        msg.route("/IHW/wallyInit", routeWallyInit);
        msg.route("/IHW/wallyCleanup", routeWallyCleanup);
        msg.route("/IHW/wallyGetSecpContext", routeWallyGetSecpContext);
        msg.route("/IHW/wallyGetNewSecpContext", routeWallyGetNewSecpContext);
        msg.route("/IHW/wallySecpContextFree", routeWallySecpContextFree);
        msg.route("/IHW/wallyBZero", routeWallyBZero);
        msg.route("/IHW/wallyFreeString", routeWallyFreeString);
        msg.route("/IHW/wallySecpRandomize", routeWallySecpRandomize);

        /* Crypto functions */

        // deprecated in libwally-core code base
        // msg.route("/IHW/wallyEcSigFromBytesLen", routeWallyEcSigFromBytesLen);
        msg.route("/IHW/wallyEcSigNormalize", routeWallyEcSigNormalize);
        msg.route("/IHW/wallyEcSigToDer", routeWallyEcSigToDer);
        msg.route("/IHW/wallyEcSigFromDer", routeWallyEcSigFromDer);
        msg.route("/IHW/wallyFormatBitcoinMessage", routeWallyFormatBitcoinMessage);
        msg.route("/IHW/wallyEcdh", routeWallyEcdh);
        // only available starting from version release_0.8.8
        // msg.route("/IHW/wallyS2cSigFromBytes", routeWallyS2cSigFromBytes);
        // msg.route("/IHW/wallyS2cCommitmentVerify", routeWallyS2cCommitmentVerify);

        /* Vaise functions */
        msg.route("/IHW/valiseInit", routeValiseInit);
        msg.route("/IHW/valiseGet", routeValiseGet);

        /* Bip39 functions*/
        msg.route("/IHW/bip39GetLanguages", routeBip39GetLanguages);
        msg.route("/IHW/bip39GetWordlist", routeBip39GetWordlist);
        msg.route("/IHW/bip39GetWord", routeBip39GetWord);
        msg.route("/IHW/bip39MnemonicFromBytes", routeBipMnemonicFromBytes);
        msg.route("/IHW/bip39MnemonicToBytes", routeBipMnemonicToBytes);
        msg.route("/IHW/bip39MnemonicValidate", routeBipMnemonicValidate);
        msg.route("/IHW/mnemonicToPrivateKey", routeMnemonicToPrivateKey);
//        msg.route("/IHW/bip39MnemonicToSeed512", routeBipMnemonicToSeed512);
        msg.route("/IHW/bip39NumberBouncer", routeBip39NumberBouncer);
        msg.route("/IHW/valiseSign", routeValiseSign);

        msg.route("/IHW/secp256k1PubKey", routeSecp256k1PubKey);
        msg.route("/IHW/wallyEcSigFromBytes", routeWallyEcSigFromBytes);
        msg.route("/IHW/wallyEcSigVerifyPubkeyHash", routeWallyEcSigVerifyPubkeyHash);
        msg.route("/IHW/wallyEcSigVerify", routeWallyEcSigVerify);


        msg.route("/IHW/mnemonic", routeMnemonic);
        msg.route("/IHW/mnemonicFromBytes", routeMnemonicFromBytes);
        msg.route("/IHW/mnemonicToBytes", routeMnemonicToBytes);
        //msg.route("/IHW/seed", routeEntropy);
        msg.route("/IHW/bip32_key_from_seed", routeBip32KeyFromSeed);
        msg.route("/IHW/bip32KeyFromParent", routeBip32KeyFromParent);


        msg.route("/IHW/trnd", routeTrnd);
        // msg.route("/IHW/cbor", routeCborEcho);
    }

    /*if(!msg.hasError())
    {
        static int32_t sequencenumber=0;
        // we can sneak an addition onto the end of the bundle
        msg.add("/sequencenumber").add(sequencenumber++);
        SLIPSerial.beginPacket(); // mark the beginning of the OSC Packet
            msg.send(SLIPSerial);
        SLIPSerial.endPacket();     
    }*/


    delay(20);
}
